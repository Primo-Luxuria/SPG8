<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manage textbooks</title>
    <style>
        input[type="text"],
        input[type="number"],
        input[type="date"],
        select,
        textarea {
            margin-bottom: 8px;
            height: 40px !important; /* Increased height */
            padding: 10px 12px !important;
            font-size: 16px !important;
            border: 1px solid #ccc !important; /* Softer border color */
            border-radius: 8px !important;
            transition: all 0.3s ease;
            min-width: 200px !important;
        }
    
        /* Focus states */
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus,
        textarea:focus {
            border-color: #0077C8 !important;
            box-shadow: 0 0 0 2px rgba(0, 119, 200, 0.1) !important;
            outline: none !important;
        }
    
        /* Dropdown specific */
        select#courseSemester {
            background-color: #ffffff !important;
            border-color: #cccccc !important;
            background-image: url("data:image/svg+xml;utf8,<svg fill='%23666' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>") !important;
        }
    
        /* Textareas */
        textarea {
            height: auto !important;
            min-height: 120px !important;
            line-height: 1.5 !important;
        }
    
        /* Error message */
        #errorText {
            color: #dc3545 !important;
            font-size: 14px !important;
            margin-top: 8px !important;
            padding: 8px 12px !important;
            border-radius: 6px !important;
            background-color: #f8d7da !important;
            border: 1px solid #f5c6cb !important;
        }
    
        /* Hover states */
        input:hover,
        select:hover,
        textarea:hover {
            border-color: #999 !important;
        }
    
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    
        body {
            font-family: Arial, sans-serif;
            color: #333;
        }
    
        /* Header Styles */
        .header {
            background-color: #0077C8;
            color: white;
            padding: 25px 0;
            text-align: center;
        }
    
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
    
        .welcome-bar {
            background-color: #005fa3;
            padding: 15px 0;
            text-align: center;
            color: white;
            font-size: 1.2rem;
            letter-spacing: 0.5px;
        }
    
        /* Main Content Container */
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 20px;
        }
    
        /* Textbook Form Section */
        .textbook-form {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 3px 15px rgba(0,0,0,0.1);
        }
    
        .textbook-container {
            background: #ffffff !important;
            border: 1px solid #e0e0e0 !important;
            border-radius: 12px !important;
            padding: 20px !important;
            margin: 20px 0 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
            transition: all 0.3s ease;
        }
    
        /* Course container hover effect */
        .textbook-containerr:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
    
        /* Consistent details styling */
        .textbook-container details {
            background: #f8f9fa !important;
            border-radius: 8px !important;
            margin: 12px 0 !important;
            border: 1px solid #dee2e6 !important;
        }
    
        /* Summary element styling */
        .textbook-container details summary {
            padding: 14px !important;
            font-weight: 600 !important;
            color: #2e3a42 !important;
            cursor: pointer !important;
        }
    
        /* Nested elements consistency */
        .textbook-container details details {
            background: #ffffff !important;
            margin: 8px 0 !important;
        }
    
        /* Remove button styling */
        .textbook-container .remove-btn {
            margin-top: 20px !important;
            width: 100% !important;
            padding: 12px !important;
            font-size: 16px !important;
        }
        
        body { font-family: Arial, sans-serif; }
	    textarea {width: 100%;min-height: 100px;resize: vertical;font-size: 16px;padding: 8px;}
        .textbook-container { background: #f4f4f4; padding: 15px; margin: 15px 0; border-radius: 8px; width: 80%; }
        details { margin-top: 10px; padding: 10px; background: #e0e0e0; border-radius: 5px; }
        .remove-btn { background: red; color: white; padding: 8px; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;}
        .tab-container { margin-top: 10px; }
        .tabs { display: flex; cursor: pointer; border-bottom: 2px solid #cccccc; }
        .tab { padding: 8px 12px; border: 1px solid #cccccc; border-bottom: none; background: #d9d9d9; }
        .tab.active { background: #ffffff; font-weight: bold; }
        .tab-content { display: none; padding: 10px; height: 120px; overflow-y: auto; border: 1px solid #ccc; }
        .tab-content.active { display: block;}
        .add-btn { background: #0077C8; color: white; padding: 5px 10px; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;}
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); overflow:hidden; align-items:center; justify-content:center;}
        .modal-content { background: white; padding: 20px; width: 50%; max-height:80vh; overflow-y:auto; margin: 5% auto; border-radius: 10px;}
        .close-btn { background: red; color: white; padding: 5px 10px; border: none; border-radius: 5px; cursor: pointer;}
        .form-container {display: flex;flex-direction: column;align-items:left;padding: 20px;width: 300px;}
        .form-group {display: flex;align-items: left;margin-bottom: 10px;width: 100%;}
        .form-group label {width: 120px;text-align: right;margin-right: 10px;}
        .form-group input {flex: 1;}  
        .context-menu {display: none;position: fixed;background: white;border: 1px solid #ccc;box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);z-index: 1000;}
        .context-menu ul {list-style: none;margin: 0;padding: 0;}
        .context-menu ul li {padding: 8px 12px;cursor: pointer;}
        .context-menu ul li:hover {background: #f0f0f0;}
    </style>
</head>
<body style="background-color: #2e3a42;">
    <div class="header">
        <h1>QuizPress</h1>
        <p>Manage Your Quizzes with Eases</p>
    </div>

     <!-- Welcome Bar -->
     <div class="welcome-bar">
        Welcome!
    </div>
    
    <!-- Course Input Form -->
    <main class="container">
        <div class="textbook-form">
            <h2>Manage Your Textbooks</h2>

<body style="background-color: #2e3a42;">

    <!-- Textbook Input Form -->

    <div style="background:#e0e0e0;padding:20px;">
    <input type="text" id="title" placeholder="Enter Textbook Title" required>
    <input type="text" id="author" placeholder="Enter Textbook Author" required>
    <input type="text" id="version" placeholder="Enter Textbook Version" required>
    <input type="text" id="isbn" placeholder="Enter Textbook ISBN" required>
    <input type="text" id="link" placeholder="Enter Textbook Link" required>
    <input type="number" id="chapters" min="1" placeholder="Number of Chapters" required><br/><br/>
    
    <button onclick="addTextbook()">Add Textbook</button>
    <style>
        /* Add this to your existing button styles */
        button[onclick="addTextbook()"] {
            background-color: #0077C8 !important;
            color: white !important;
            padding: 12px 24px !important;
            font-size: 16px !important;
            border: none !important;
            border-radius: 8px !important;
            cursor: pointer !important;
            transition: background-color 0.3s ease !important;
        }
        
        /* Hover effect */
        button[onclick="addCourse()"]:hover {
            background-color: #005fa3 !important;
        }
        
        /* Active state */
        button[onclick="addCourse()"]:active {
            background-color: #004880 !important;
        }
        </style>
    </div>

    <div id="textbookList"></div>

    <!-- Context Menu for Questions -->
    <div id="contextMenu" class="context-menu">
        <ul>
            <li onclick="editItem()">Edit</li>
            <li onclick="deleteItem()">Delete</li>
            <li onclick="addFeedback()">Add Feedback</li>
            <li onclick="viewFeedback()">View Feedback</li>
        </ul>
    </div>
    
    <!-- Primary Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal()">Back</button>
            <h2 id="modalTitle">Edit</h2>
            <div id="modalBody"></div>
        </div>
    </div>

    <!-- Modal for Question Selection -->
    <div id="questionModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeQuestionModal()">Back</button>
            <h2 id="questionModalTitle">Select Questions</h2>
            <div id="questionModalBody"></div>
        </div>
    </div>

<script>

//Can be used for session-level storage and testing
var masterQuestionList = {};
var masterTestList = {};
var masterTemplateList = {};
var masterAttachmentList = {};
var textbookList = {};
var masterCoverPageList = {};

/**
 * Defines the UI for a given textbook, used to interact with everything else
 * Preconditions: requires users provide all of the textbook addition data
 * Postconditions: Creates a textbook UI with tabbed panes for question and test data
*/
function addTextbook() {
    
    const title = document.getElementById('title').value.trim();
    const author = document.getElementById('author').value.trim();
    const version = document.getElementById('version').value.trim();
    const isbn = document.getElementById('isbn').value.trim();
    const link = document.getElementById('link').value.trim();
    const chapters = document.getElementById('chapters').value.trim();

    const textbook = {
        'title': title,
        'author': author,
        'version': version,
        'isbn': isbn,
        'link': link
    }

    if (!title || !author || !version || !isbn || !link || !chapters) {
        alert("All fields (Title, Author, Version, ISBN, Link, and Number of Chapters) are required.");
        return;
    }   


    if (textbookList[isbn]) {
        alert("Error: A testbook with that isbn already exists.");
        return;
    }


    const textbookContainer = document.createElement('div');
    textbookContainer.classList.add('textbook-container');
    textbookContainer.innerHTML = `
        <details>
            <summary><strong>${title}</strong> (ID: ${isbn})</summary>
            <details>
                <summary>Questions</summary>
            <button class="add-btn" onclick="openEditor('Question', '${isbn}')">Add Question</button>
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" onclick="switchTab(event, 'tf-${isbn}')">True/False</div>
                    <div class="tab" onclick="switchTab(event, 'mc-${isbn}')">Multiple Choice</div>
                    <div class="tab" onclick="switchTab(event, 'sa-${isbn}')">Short Answer</div>
                    <div class="tab" onclick="switchTab(event, 'es-${isbn}')">Essay</div>
                    <div class="tab" onclick="switchTab(event, 'ma-${isbn}')">Matching</div>
                    <div class="tab" onclick="switchTab(event, 'ms-${isbn}')">Multiple Selection</div>
                    <div class="tab" onclick="switchTab(event, 'fb-${isbn}')">Fill in the Blank</div>
                </div>
                <div class="tab-content active" id="tf-${isbn}"><p>True/False questions go here...</p></div>
                <div class="tab-content" id="es-${isbn}"><p>Essay questions go here...</p></div>
                <div class="tab-content" id="mc-${isbn}"><p>Multiple Choice questions go here...</p></div>
                <div class="tab-content" id="sa-${isbn}"><p>Short Answer questions go here...</p></div>
                <div class="tab-content" id="ma-${isbn}"><p>Matching questions go here...</p></div>
                <div class="tab-content" id="ms-${isbn}"><p>Multiple Selection questions go here...</p></div>
                <div class="tab-content" id="fb-${isbn}"><p>Fill in the Blank questions go here...</p></div>
            </div>
            </details>

            <details>
                <summary>Cover Pages</summary>
                    <button class="add-btn" onclick="openEditor('Cover Page', '${isbn}')">Add Cover Page</button>
                    <div id="coverpages-${isbn}"><p>You have not added any cover pages yet...</div>
            </details>

            <details>
                <summary>Templates</summary>
                    <button class="add-btn" onclick="openEditor('Template', '${isbn}')">Add Template</button>
                    <div id="templates-${isbn}"><p>You have not added any templates yet...</p></div>
            </details>

            <details>
                <summary>Tests</summary>
                <button class="add-btn" onclick="openEditor('Test', '${isbn}')">Add Test</button>
                <button class="add-btn" onclick="openImporter('Test', '${isbn}')">Import Test</button>
                <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" onclick="switchTab(event, 'drafts-${isbn}')">Drafts</div>
                    <div class="tab" onclick="switchTab(event, 'published-${isbn}')">Published Tests</div>
                </div> 
                <div class="tab-content active" id="drafts-${isbn}"><p>Saved drafts go here...</p></div>
                <div class="tab-content" id="published-${isbn}"><p>Published tests go here...</p></div>
            </div>
            </details>

            <details>
                <summary>Attachments</summary>
                <button class="add-btn" onclick="openEditor('Attachment', '${isbn}')">Add Attachment</button>
                <div id="attachments-${isbn}"><p>You have not uploaded any attachments yet...</p></div>
            </details>
            <button class="remove-btn" onclick="confirmRemoveTextbook(this)">Remove textbook</button>
        </details>
    `;

    document.getElementById('textbookList').appendChild(textbookContainer);
    document.getElementById('title').value = "";
    document.getElementById('author').value = "";
    document.getElementById('version').value = "";
    document.getElementById('isbn').value = "";
    document.getElementById('link').value = "";
    document.getElementById('chapters').value = "";

    

    const questionList = {
        'tf': [],
        'mc': [],
        'sa': [],
        'es': [],
        'ma': [],
        'ms': [],
        'fb': []
    };

    const testList = {
        'drafts': [],
        'published': []
    };

    let today = new Date();
    let year = today.getFullYear();
    let month = today.getMonth() + 1;
    let date = today.getDate();

    if(month<10){ //ensuring that the values are valid for HTML date YYYY-MM-DD
        month = '0' + month;
    }
    if(date<10){
        date = '0' + date;
    }   

    masterQuestionList[isbn] = questionList;
    masterTestList[isbn] = testList;
    masterCoverPageList[isbn] = [];
    masterTemplateList[isbn] = [];
    masterTemplateList[isbn].bonusQuestions = [];

    const coverPageDefault = {
        name: "Default 1st Test",
        testNum: 1,
        date: `${year}-${month}-${date}`,
        file: "defaultpage",
        showFilename: true,
        blank: "TR",
        instructions: "Grade according to the rubric, giving partial credit where indicated",
        published: 1,
    };

    const coverPageDefault2 = {
        name: "Default 2nd Test",
        testNum: 2,
        date: `${year}-${month}-${date}`,
        file: "defaultpage_2",
        showFilename: true,
        blank: "TR",
        instructions: "Grade according to the rubric, giving partial credit where indicated",
        published: 1,
    };

    const coverPageDefault3 = {
        name: "Default 3rd Test",
        testNum: 3,
        date: `${year}-${month}-${date}`,
        file: "defaultpage_3",
        showFilename: true,
        blank: "TR",
        instructions: "Grade according to the rubric, giving partial credit where indicated",
        published: 1,
    };

    masterCoverPageList[isbn].push(coverPageDefault, coverPageDefault2, coverPageDefault3);
    updateCoverPages(isbn);

    const templateDefault = {
        name: "System Default",
        titleFont: "Times New Roman",
        titleFontSize: 36,
        subtitleFont: "Times New Roman",
        subtitleFontSize: 24,
        bodyFont: "Times New Roman",
        bodyFontSize: 12,
        pageNumbersInFooter: true,
        pageNumbersInHeader: false,
        headerText: "",
        footerText: "Please read all questions carefully",
        coverPageType: 0,
        bonusSection: false,
        bonusQuestions: [],
        partStructure: [
            {
                partNumber: 1,
                sections: [
                    { sectionNumber: 1, questionType: "tf" }
                ]
            }
        ],
        published: 1  
    };

    masterTemplateList[isbn].push(templateDefault);
    updateTemplates(isbn);

    if(!masterAttachmentList[isbn]){
        let attachmentList = [];
        masterAttachmentList[isbn] = attachmentList;
    }

}

/**
 * Used to remove a textbook
 * Precondition: the textbook exists
 * Postcondition: the textbook no longer exists
 * 
*/
function confirmRemoveTextbook(button) {
    if (confirm("Are you sure you want to delete this textbook? This action cannot be undone.")) {
        button.closest('.textbook-container').remove();
    }
}

/**
 * Switches between the tabs of a tabbed pane
 * Precondition: valid tab ID to switch to
 * Postcondition: switches to that tab in the correct tabbed pane, activates a different one
*/
function switchTab(event, tabID) {
            const parentContainer = event.target.closest('.tab-container');
            const tabs = parentContainer.querySelectorAll('.tab');
            const contents = parentContainer.querySelectorAll('.tab-content');

            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabID).classList.add('active');
}

/**
 * Opens the editor modal. This behaves differently depending on what is edited
 * Currently the attachment, template, question, and test editors are implemented
 * Precondition: valid textbook, edit button pushed
 * Postcondition: opens up a modal over the webpage content that allows you to create new data
*/
function openEditor(type, isbn) {
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = `Add ${type}`;

    let formContent = '';    

    if (type != "Question"){
        formContent += `
        <label>${type} Name:</label><br/>
        <input type="text" id="nameField"><br><br>
    `;
    }

    if (type === "Question") {
        formContent += `
            <label>Question:</label><br/>
            <textarea id="questionField" rows="5" placeholder="Enter question text here..."></textarea><br><br>
            
            <label>Question Type:</label><br/>
            <select id="typeField" onchange="updateQuestionForm()">
                <option value="" disabled selected>Select Question Type</option>
                <option value="tf">True/False</option>
                <option value="mc">Multiple Choice</option>
                <option value="sa">Short Answer</option>
                <option value="es">Essay</option>
                <option value="ma">Matching</option>
                <option value="ms">Multiple Selections</option>
                <option value="fb">Fill in the Blank</option>
            </select><br><br>

            <div id="questionSpecificFields"></div>

            <label>Point Value:</label><br/>
            <input type="number" id="pointValueField" min="1"><br><br>
            
            <label for="qChapter" >Chapter:</label><br/>    
            <input type="number" id="qChapter" min="1"><br><br>

            <label for="qSection" >Section:</label><br/> 
            <input type="number" id="qSection" min="1"><br><br>

            <label>Estimated Time to Solve (Minutes):</label><br/>
            <input type="number" id="qTimeField" min="1"><br><br>

            <label>Grading Instructions:</label><br/>
            <textarea id="instructionField" rows="6" placeholder="Grading instructions should be provided for partial credit, short or long answer questions, or questions where a rubric is necessary."></textarea><br><br>

            <label>Reference Text (Optional):</label><br/>
            <textarea id="refField" rows="3" placeholder="Reference text if needed..."></textarea><br><br>

            <label>Embedded Graphic (Optional):</label><br/>
            <select id="qGraphicField">
                <option value="" disabled selected>Select a graphic</option>
            </select><br><br>
        
            <label>Embedded Graphic for the Correct Answer (Optional):</label><br/>
            <select id="ansGraphicField">
                <option value="" disabled selected>Select a graphic</option>
            </select><br><br>
        
            <label>Instructor Comments (Optional):</label><br/>
            <textarea id="instructorCommentField" placeholder="Comments go here"></textarea><br><br>

            <button class="add-btn" onclick="addQuestion('${isbn}')">Submit Question</button>
        `;
    }

    if (type === "Cover Page"){
        //Needs: test instructions, textbook number, test number, date of test, filename of the test,
        //  blank for student name, and grading instructions for the key
        formContent+= `
        <div style="background:#e0e0e0;padding:20px;" id="coverPageEditor">
            <p>Create your Cover Page!</p><br/>
            <label>Test Number</label>
            <input type="number" id="tNum" min="0"/><br/>

            <label>Test Date</label>
            <input type="date" id="tDate"/><br/>

            <label>Test Filename (no extension)</label>
            <input id="filename" type="text"/><br/>

            <label>Filename Present on CoverPage</label>
            <input id="filenameTF" type="checkbox"/><br/>

            <label>Student Name Location</label>
            <select id="nameBlankSelector">
                <option value="" disabled selected>Please select a location</option>
                <option value="TR">Top Right</option>
                <option value="TL">Top Left</option>
                <option value="BT">Below the Title</option>
            </select><br/><br/>

            <label>Grading Instructions for Key</label>
            <textarea id="instructions" name="instruct" rows="3" placeholder="Add your instructions for grading here. These will go into the test key."></textarea>
            <br/>
            <button class="add-btn" onclick="submitCoverPage('${isbn}')">Submit</button>
        </div>
        `;
    }


    if (type === "Test"){
        formContent+= `
        <div style="background:#e0e0e0;padding:20px;" id="testEditor">
            <p>Choose a Template!</p><br/>
            <div id=templateSelectorPane>
                <select id=templateSelector>
                    <option value="" disabled selected>Please Select a Template</option>
                </select> <button id=templateSelection onclick="updateTestParts('${isbn}')">Select This One!</button>
                <div id="testParts"> </div>
            </div>
            <button class="add-btn" id="testDraftButton" onclick="saveTest('${isbn}', '${false}')">Save as Draft</button>
            <button class="add-btn" id="testPublishButton" onclick="saveTest('${isbn}', '${true}')">Publish Test</button>
        </div>
        `;
        setTimeout(() => {
        updateTemplateSelection(isbn);
        }, 50);
        
    }


     if (type === "Template") {
        formContent += `
            <div  style="background:#e0e0e0;padding:20px;" id="templateEditor"> 
	    <h1>Font Settings</h1>
  	    <label>Title Font and Font Size:</label><br/>
        <select id="titleFont">
            <option value="" selected disabled>Please choose a font</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Arial">Arial</option>
            <option value="Calibri">Calibri</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Georgia">Georgia</option>
            <option value="Cambria">Cambria</option>
            <option value="Garamond">Garamond</option>
        </select>
	    <input type="number" id="titleFontSize" min="1" value="36"><br/><br/>

	    <label>Subtitle Font and Font Size:</label><br/>
	    <select id="subtitleFont">
            <option value="" selected disabled>Please choose a font</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Arial">Arial</option>
            <option value="Calibri">Calibri</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Georgia">Georgia</option>
            <option value="Cambria">Cambria</option>
            <option value="Garamond">Garamond</option>
        </select>
	    <input type="number" id="subtitleFontSize" min="1" value="24"><br/><br/>

    	<label>Body Font and Font Size:</label><br/>
	    <select id="bodyFont">
            <option value="" selected disabled>Please choose a font</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Arial">Arial</option>
            <option value="Calibri">Calibri</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Georgia">Georgia</option>
            <option value="Cambria">Cambria</option>
            <option value="Garamond">Garamond</option>
        </select>
	    <input type="number" id="bodyFontSize" min="1" value="12"><br/><br/>
        
        
        <h1>Tags Section (Optional)</h1>
        <div class="form-container">
            <div class="form-group"><label>Test Name </label> <input type="text" id="tempTestName"></div>
            <div class="form-group"><label>Date </label> <input type="text" id="tempDate"></div>
            <div class="form-group"><label>textbook Number </label> <input type="text" id="temptextbookNum"></div>
        </div>

  	    <h1>Header and Footer Settings</h1>
        <label>Location of Student Score Blank (On the second page of the test)</label>
        <select id="studentScoreSelector">
            <option value="" disabled selected>Please Select a Location</option>
            <option value="TR"> Top Right</option>
            <option value="TL"> Top Left</option>
        </select><br/><br/>
	    <label>Page Numbers in Header</label><br/>
	    <input type="checkbox" id="pageNumH"><br/>
	    <label>Page Numbers in Footer</label><br/>
	    <input type="checkbox" id="pageNumF"><br/><br/>
	    <textarea id="headerField" rows="3" placeholder="Enter any desired header text ..."></textarea>
	    <textarea id="footerField" rows="3" placeholder="Enter any desired footer text..."></textarea>
	    
	    <h1>Cover Page Selection</h1><br/>
	    <select id="coverPageSelector">
		    <option value="" disabled selected>Please Select a Cover Page</option>
	    </select><br/><br/>

	    <h1>Test Structure Settings</h1>
	    <label>Number of Parts:</label>
        <input type="number" id="partCount" min="1" value="1">
        <button onclick="updateParts()">Update</button>
        <div style="background:#c0c0c0;padding:20px;" id="partsContainer"><p>No Parts Chosen</p></div>
            
	    
	    <h1>Bonus Question Section Toggle</h1>
	    <select id="bonusToggle" onchange="toggleBonusQuestionSelection('${isbn}')">
		<option value="True">Bonus Section</option>
		<option value="False" selected>No Bonus Section</option>
	    </select><br/><br/>
        <button class="add-btn" id="selectBonusQuestionsBtn" style="display:none;" onclick="openBonusQuestionModal('${isbn}')">Select Bonus Questions</button>
        <button class="add-btn" onclick="addTemplate('${isbn}')">Submit Template</button></div>
        `;

        setTimeout(() => {
        updatePageSelection(isbn);
        }, 50);
    }

    
    if (type === "Attachment"){
        formContent+=`
            <input type="file" id="newAttachment" name="attachment">
	        <button class="add-btn" onclick="submitAttachment('${isbn}')">Submit Attachment</button>
        `;
   }

    // Ensure the modal content is updated
    modalBody.innerHTML = formContent;

    // Show the modal
    modal.style.display = "flex";
    setTimeout(() => {
        modal.style.opacity = "1";
    }, 10);

    if (type === "Question") {
        updateGraphicSelectors(isbn);
    }

}

function updateParts() {
     const partCount = parseInt(document.getElementById("partCount").value);
     const partsContainer = document.getElementById("partsContainer");
     partsContainer.innerHTML = ""; // Clear existing content
 
     for (let i = 1; i <= partCount; i++) {
         let sectionInputId = `sectionCount-${i}`;
         partsContainer.innerHTML += `
             <div id="part-${i}">
                 <label>Sections in Part ${i}:</label>
                 <input type="number" id="${sectionInputId}" min="1" value="1"> 
                 <button onclick="updateSections(${i})">Update</button>
                 <div style="background:#c0c0c0;padding:20px;" id="sectionsContainer-${i}"><p>No Sections Chosen...</p></div>
             </div><br>
         `;
     }
 }

 function updateSections(partNumber) {
     const sectionCount = parseInt(document.getElementById(`sectionCount-${partNumber}`).value);
     const sectionsContainer = document.getElementById(`sectionsContainer-${partNumber}`);
     sectionsContainer.innerHTML = ""; // Clear old sections
 
     for (let j = 1; j <= sectionCount; j++) {
         sectionsContainer.innerHTML += `
             <label>Question Type for Section ${j}:</label>
             <select>
                 <option value="tf">True/False</option>
                 <option value="mc">Multiple Choice</option>
                 <option value="sa">Short Answer</option>
                 <option value="es">Essay</option>
                 <option value="ma">Matching</option>
                 <option value="ms">Multiple Selections</option>
                 <option value="fb">Fill in the Blank</option>
             </select><br>
         `;
     }
 }


/** 
 *  Updates the graphic selectors inside of the editor modal during openEditor() execution
 * Is active when the editorModal is in question mode
 * Precondition: valid isbn
 * Postcondition: graphic selectors are updated with a list of files from the Attachments Section
*/
function updateGraphicSelectors(isbn) {
    const qGraphicField = document.getElementById('qGraphicField');
    const ansGraphicField = document.getElementById('ansGraphicField');

    qGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';
    ansGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';

    if (!masterAttachmentList[isbn] || masterAttachmentList[isbn].length === 0) {
        alert("No attachments available for this textbook!");
        return;
    }

    masterAttachmentList[isbn].forEach((attachment, index) => {
        const option = document.createElement('option');
        option.value = attachment.name; //TODO: change this to index, store attachments associated to questions from database
        option.textContent = attachment.name;
        qGraphicField.appendChild(option);

        const ansOption = document.createElement('option');
        ansOption.value = attachment.name;
        ansOption.textContent = attachment.name;
        ansGraphicField.appendChild(ansOption);
    });
}

/**
 * Updates the different possible options for a question type in the question editor
 * Precondition: valid question type
 * Postcondition: question editor is updated with the correct fields for the question type
*/
function updateQuestionForm() {
    const type = document.getElementById('typeField').value;
    const questionSpecificFields = document.getElementById('questionSpecificFields');
    questionSpecificFields.innerHTML = '';

    if (type === 'tf') {
        questionSpecificFields.innerHTML = `
            <label>Correct Answer:</label><br/>
            <select id="answerField">
                <option value="true">True</option>
                <option value="false">False</option>
            </select><br><br>
        `;
    } else if (type === 'sa' || type === 'es') {
        questionSpecificFields.innerHTML = `
            <label>Correct Answer:</label><br/>
            <textarea id="answerField" rows="4" placeholder="Enter the correct answer here..."></textarea><br><br>
        `;
    } else if (type === 'mc') {
        questionSpecificFields.innerHTML = `
            <label>Options:</label><br/>
            <input type="text" id="optionA" placeholder="Option A"><br>
            <input type="text" id="optionB" placeholder="Option B"><br>
            <input type="text" id="optionC" placeholder="Option C"><br>
            <input type="text" id="optionD" placeholder="Option D"><br><br>
            <label>Correct Answer:</label><br/>
            <select id="answerField">
                <option value="A">A</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="D">D</option>
            </select><br><br>
        `;
    } else if (type === 'ma') {
        questionSpecificFields.innerHTML = `
            <label>Number of Options:</label><br/>
            <input type="number" id="numOptions" min="2" step="2" onchange="updateOptions('${type}')"><br><br>
            <div id="optionsContainer"></div>
        `;
    } else if (type === 'ms') {
        questionSpecificFields.innerHTML = `
            <label>Number of Options:</label><br/>
            <input type="number" id="numOptions" min="1" max="20" onchange="updateOptions('${type}')"><br><br>
            <div id="optionsContainer"></div>
        `;
    } else if (type === 'fb') {
        questionSpecificFields.innerHTML = `
            <label>Number of Blanks:</label><br/>
            <input type="number" id="numBlanks" min="1" onchange="updateOptions('${type}')"><br><br>
            <div id="optionsContainer"></div>
            <label>Include Formula:</label>
            <input type="checkbox" id="includeFormula" onchange="toggleFormulaInput()"><br><br>
            <div id="formulaContainer"></div>
        `;
    }
}

/**
 * Toggles a formula input field in the question editor for fill in the blank questions 
 * Precondition: valid checkbox state
 * Postcondition: formula input field is toggled on or off
 * Variation: May be used for the numeric field instead in the future (TODO)
*/
function toggleFormulaInput() {
    const includeFormula = document.getElementById('includeFormula').checked;
    const formulaContainer = document.getElementById('formulaContainer');
    if (includeFormula) {
        formulaContainer.innerHTML = `
            <label>Formula:</label><br/>
            <input type="text" id="formulaField" placeholder="Enter the formula here..."><br><br>
        `;
    } else {
        formulaContainer.innerHTML = '';
    }
}

/**
 * Adding the cover page to the list of coverpages
 * Precondition: all necessary data is in the coverpage editor
 * Postcondition: cover page added to the list
*/
function submitCoverPage(isbn) {
    const pageName = document.getElementById("nameField").value.trim();
    const testNumber = document.getElementById("tNum").value.trim();
    const testDate = document.getElementById("tDate").value.trim();
    const filename = document.getElementById("filename").value.trim();
    const filenameTF = document.getElementById("filenameTF").checked;
    const nameBlankSelector = document.getElementById("nameBlankSelector").value.trim();
    const gradingInstructions = document.getElementById("instructions").value.trim();

    if (!pageName || !testNumber || !testDate || !filename || !nameBlankSelector || !gradingInstructions) {
        alert("Cover page name, Test number, test date, filename, name blank selection, and grading instructions are required fields!");
        return;
    }

    if (!masterCoverPageList[isbn]) {
        masterCoverPageList[isbn] = [];
    }

    const coverPage = {
        name: pageName,
        testNum: testNumber,
        date: testDate,
        file: filename,
        showFilename: filenameTF,
        blank: nameBlankSelector,
        instructions: gradingInstructions,
        feedback: []
    };

    masterCoverPageList[isbn].push(coverPage);
    updateCoverPages(isbn);
    closeModal();
    alert("Added a cover page");
}

/**
 * Submit attachments to the attachmentList
 * Precondition: valid attachment
 * Postcondition: attachment posted to attachmentList
*/
function submitAttachment(isbn) {
    const attachment = document.getElementById("newAttachment").files[0];
    const name = document.getElementById("nameField").value.trim();

    if (!attachment || !name) {
        alert("Attachment file and name are required.");
        return;
    }

    if (!masterAttachmentList[isbn]) {
        masterAttachmentList[isbn] = [];
    }

    masterAttachmentList[isbn].push({ name: name, file: attachment });
    updateAttachments(isbn);
    closeModal();
    alert("Attachment added successfully!");
}

/**
 * Updates the attachments for a given textbook
 * Precondition: valid isbn, attachmentList
 * Postcondition: the attachments dropdown will have interactible div containers for each attachment
*/
function updateAttachments(isbn) {
    const attachmentList = masterAttachmentList[isbn];
    const attachmentContainer = document.getElementById("attachments-" + isbn);
    attachmentContainer.innerHTML = "";

    if (attachmentList.length === 0) {
        attachmentContainer.innerHTML = '<p>You have not uploaded any attachments yet...</p>';
        return;
    }

    attachmentList.forEach((attachment, index) => {
        const attachmentDiv = document.createElement("div");
        attachmentDiv.style.backgroundColor = "#d0d0d0";
        attachmentDiv.style.padding = '5px';
        attachmentDiv.style.marginBottom = '8px';
        attachmentDiv.style.borderBottom = '1px solid #ccc';
        attachmentDiv.classList.add('context-menu-target');
        attachmentDiv.dataset.itemType = 'attachment';
        attachmentDiv.dataset.itemIndex = index;
        attachmentDiv.dataset.isbn = isbn;

        const attachmentLabel = document.createElement("p");
        attachmentLabel.innerHTML = `Attachment ${index + 1}: ${attachment.name}`;
        attachmentDiv.appendChild(attachmentLabel);

        attachmentContainer.appendChild(attachmentDiv);
    });
}

/**
 * Adds a template to the templateList
 * Precondition: valid isbn and template info
 * Postcondition: adds a new template to the list
*/
function addTemplate(isbn) {
    const templateName = document.getElementById('nameField').value.trim();
    const coverPageType = document.getElementById('coverPageSelector').value;

    const titleFont = document.getElementById('titleFont').value.trim();
    const titleFontSize = parseInt(document.getElementById('titleFontSize').value, 10);
    const subtitleFont = document.getElementById('subtitleFont').value.trim();
    const subtitleFontSize = parseInt(document.getElementById('subtitleFontSize').value, 10);
    const bodyFont = document.getElementById('bodyFont').value.trim();
    const bodyFontSize = parseInt(document.getElementById('bodyFontSize').value, 10);

    const pageNumbersInHeader = document.getElementById('pageNumH').checked;
    const pageNumbersInFooter = document.getElementById('pageNumF').checked;

    const headerText = document.getElementById('headerField').value.trim();
    const footerText = document.getElementById('footerField').value.trim();

    const bonusSection = document.getElementById('bonusToggle').value === 'True';

    if (!templateName) {
        alert("Error: Template Name is required.");
        return;
    }
    if (!titleFont || !subtitleFont || !bodyFont) {
        alert("Error: All font fields must be filled.");
        return;
    }
    if (isNaN(titleFontSize) || isNaN(subtitleFontSize) || isNaN(bodyFontSize)) {
        alert("Error: Font sizes must be valid numbers.");
        return;
    }
    if (!coverPageType) {
        alert("Error: You must choose a cover page type.");
        return;
    }
    const partStructure = collectPartStructure();
    if (!partStructure) {
        alert("Error: Template must include a valid part structure.");
        return;
    }
    if (bonusSection && (!masterTemplateList[isbn].bonusQuestions || masterTemplateList[isbn].bonusQuestions.length === 0)) {
        alert("Error: You must select bonus questions if the bonus section is enabled.");
        return;
    }

    const templateData = {
        name: templateName,
        titleFont: titleFont,
        titleFontSize: titleFontSize,
        subtitleFont: subtitleFont,
        subtitleFontSize: subtitleFontSize,
        bodyFont: bodyFont,
        bodyFontSize: bodyFontSize,
        pageNumbersInHeader: pageNumbersInHeader,
        pageNumbersInFooter: pageNumbersInFooter,
        headerText: headerText,
        footerText: footerText,
        coverPageType: coverPageType,
        partStructure: partStructure,
        bonusSection: bonusSection,
        bonusQuestions: masterTemplateList[isbn].bonusQuestions || [],
        feedback: []
    };

    if (!masterTemplateList[isbn]) {
        masterTemplateList[isbn] = [];
    }

    masterTemplateList[isbn].bonusQuestions
    masterTemplateList[isbn].push(templateData);

    alert("Template added successfully!");
    console.log("Saved Template:", templateData);

    updateTemplates(isbn);
    closeModal();
}


/**
 * This grabs the structure of the parts and sections inside of a template.
 * It makes the structure of the test that is outlined by a template a lot easier
 * to work with in other methods, since you can grab a template's partStructure instead of
 * its sections and parts and questions invidually.
 * Precondition: valid part and section count choices, valid question type choices
 * Postcondition: outputs a structure of parts and sections for a template
*/
function collectPartStructure() {
    const partCount = parseInt(document.getElementById('partCount').value);
    const partStructure = [];

    // Validate part count
    if (isNaN(partCount) || partCount < 1) {
        alert("Error: Please enter a valid number of parts.");
        return null; // Return null instead of undefined to prevent further execution
    }

    for (let i = 1; i <= partCount; i++) {
        const sectionCountInput = document.getElementById(`sectionCount-${i}`);
        
        if (!sectionCountInput) {
            alert(`Error: Section count input is missing for Part ${i}.`);
            return null;
        }

        const sectionCount = parseInt(sectionCountInput.value);
        
        // Validate section count
        if (isNaN(sectionCount) || sectionCount < 1) {
            alert(`Error: Please enter a valid number of sections for Part ${i}.`);
            return null;
        }

        const part = {
            partNumber: i,
            sections: []
        };

        const sectionContainer = document.getElementById(`sectionsContainer-${i}`);
        if (!sectionContainer) {
            alert(`Error: Sections container missing for Part ${i}.`);
            return null;
        }

        const sectionSelects = sectionContainer.querySelectorAll('select');

        if (sectionSelects.length !== sectionCount) {
            alert(`Error: The number of section selectors does not match the section count for Part ${i}.`);
            return null;
        }

        sectionSelects.forEach((select, j) => {
            if (!select.value) {
                alert(`Error: Please select a question type for Section ${j + 1} in Part ${i}.`);
                return null;
            }
            
            part.sections.push({
                sectionNumber: j + 1,
                questionType: select.value
            });
        });

        partStructure.push(part);
    }

    return partStructure;
}


/**
 * Updates the potential options for cover pages when you open the template editor
 * Precondition: Valid isbn
 * Postcondition: populated selector in template editor (editmodal)
*/
function updatePageSelection(isbn) {
    const selection = document.getElementById("coverPageSelector");

    // Clear existing options
    selection.innerHTML = '<option value="" disabled selected>Please Select a Cover Page</option>';

    if (!masterCoverPageList[isbn] || masterCoverPageList[isbn].length === 0) {
        alert("No cover pages available for this textbook!");
        return;
    }

    masterCoverPageList[isbn].forEach((page, index) => {
        const newOption = document.createElement("option");
        newOption.value = index; 
        newOption.textContent = page.name;
        selection.appendChild(newOption);
    });
}


/**
 * Updates the potential options for templates when you open the test editor
 * Precondition: valid isbn
 * Postcondition: populated selector in test editor (editmodal)
*/
function updateTemplateSelection(isbn){
    if(!masterTemplateList[isbn]){
            masterTemplateList[isbn] = [];
        }else if(!masterTemplateList[isbn][0]){
            alert("No templates available for this textbook!");
        }else{
            const templateList = masterTemplateList[isbn];
            templateList.forEach((template, index)=>{
            const selection = document.getElementById("templateSelector");
            const newoption = document.createElement("option");
            newoption.value = index;
            newoption.textContent= template.name;
            selection.appendChild(newoption);
        });
    }
}



/**
 * Adding the question from the currently open editModal in question mode.
 * Preconditions: expects a valid isbn, and for all of the required fields to be present
 * Postconditions: adds the question to the appropriate array for its type in the textbook questionList
*/
function addQuestion(isbn) {
    const text = document.getElementById("questionField").value.trim();
    const type = document.getElementById("typeField").value;
    const points = document.getElementById("pointValueField").value.trim();
    const instructions = document.getElementById("instructionField").value.trim();
    const refText = document.getElementById("refField").value.trim();
    const time = document.getElementById("qTimeField").value.trim();
    const graphic = document.getElementById("qGraphicField").value;
    const ansgraphic = document.getElementById("ansGraphicField").value;
    const instcomm = document.getElementById("instructorCommentField").value;
    const chapter = document.getElementById("qChapter").value.trim();
    const section = document.getElementById("qSection").value.trim();

    if (!text || !type || !points || !instructions || !time || !chapter || !section) {
        alert("Some fields (Question, Question Type, Default Point Value, Chapter, Section, and Grading Instructions) are required.");
        return;
    }

    let answer = '';
    let prompts = [];
    let options = [];

    if (type === 'tf') {
        answer = document.getElementById("answerField").value;
    } else if (type === 'sa' || type === 'es') {
        answer = document.getElementById("answerField").value.trim();
    } else if (type === 'mc') {
        options = [
            document.getElementById("optionA").value.trim(),
            document.getElementById("optionB").value.trim(),
            document.getElementById("optionC").value.trim(),
            document.getElementById("optionD").value.trim()
        ];
        answer = document.getElementById("answerField").value;
    } else if (type === 'ma') {
        const numOptions = parseInt(document.getElementById("numOptions").value);
        for (let i = 1; i <= numOptions; i++) {
            options.push(document.getElementById(`option${i}`).value.trim());
        }
        answer = [];
        for (let i = 1; i <= numOptions / 2; i++) {
            const prompt = document.getElementById(`option${i}`).value.trim();
            const match = document.getElementById(`option${i + numOptions / 2}`).value.trim();
            answer.push({ prompt: prompt, match: match });
        }
    } else if (type === 'ms') {
        const numOptions = parseInt(document.getElementById("numOptions").value);
        for (let i = 1; i <= numOptions; i++) {
            options.push(document.getElementById(`option${i}`).value.trim());
            if (document.getElementById(`correct${i}`).checked) {
                answer.push(document.getElementById(`option${i}`).value.trim());
            }
        }
    } else if (type === 'fb') {
        const numBlanks = parseInt(document.getElementById("numBlanks").value);
        for (let i = 1; i <= numBlanks; i++) {
            answer.push(document.getElementById(`blank${i}`).value.trim());
        }
        if (document.getElementById('includeFormula').checked) {
            answer.push({ formula: document.getElementById('formulaField').value.trim() });
        }
    }

    const question = {
        text: text,
        answer: answer,
        qtype: type,
        score: points,
        directions: instructions,
        reference: refText,
        eta: time,
        img: graphic,
        ansimg: ansgraphic,
        comments: instcomm,
        prompts: prompts,
        options: options,
        chapter: chapter,
        section: section,
        tests: [],
        published: 0
    };

    if (!masterQuestionList[isbn][type]) {
        masterQuestionList[isbn][type] = [];
    }

    masterQuestionList[isbn][type].push(question);
    updateQuestionTabs(type, isbn);
    alert(`Added the ${type.toUpperCase()} Question: \n"${question.text}"\n (Worth ${question.score} points!)`);

    closeModal();
}

/**
 * Updates the test editor to have the appropriate parts and section options
 * Preconditions: A valid template with part and sections defined correctly, a valid textbook ID
 * Postconditions: Populated testeditor with all of the appropriate parts and sections
 * 
 * TODO: Check if the template has a bonus section, and add a part with one section if so.
 *       Let the teacher choose what type of question the bonus section should include
 *       Then update the section to have the appropriate syntax
*/
function updateTestParts(isbn) {
    const templateIndex = document.getElementById("templateSelector").value;
    if (!templateIndex) {
        alert("Please select a template first");
        return;
    }
    
    const template = masterTemplateList[isbn][templateIndex];
    const partStructure = template.partStructure;
    
    let test = document.getElementById("testParts");
    test.innerHTML = ""; // Clear existing content

    // Loop through each part in the template structure
    for (let i = 0; i < partStructure.length; i++) {
        let partContainer = document.createElement("div");
        partContainer.style.padding = '5px';
        partContainer.style.marginBottom = '8px';
        partContainer.style.borderBottom = '1px solid #ccc';
        partContainer.id = `part-${i}-container`;

        let partNum = i + 1;
        partContainer.innerHTML = `<h2>Part ${partNum}</h2>`;

        // Loop through each section in this part
        const sections = partStructure[i].sections;
        for (let j = 0; j < sections.length; j++) {
            let sectionContainer = document.createElement('div');
            sectionContainer.style.padding = '5px';
            sectionContainer.style.marginBottom = '8px';
            sectionContainer.style.borderBottom = '1px solid #ccc';
            sectionContainer.style.backgroundColor = '#d3d3d3';
            sectionContainer.id = `part-${i}-section-${j}-container`;

            let sectionNum = j + 1;
            const questionType = sections[j].questionType.toLowerCase();

            sectionContainer.innerHTML = `
                <h3>Section ${sectionNum}: ${questionType.toUpperCase()} Questions</h3>
                <button class="add-btn" onclick="openQuestionModal('${isbn}', ${i}, ${j}, '${questionType}')">Choose Questions</button>
                <div class="selected-questions"></div>
            `;

            partContainer.appendChild(sectionContainer);
        }

        test.appendChild(partContainer);
    }

    // Add bonus part if it exists
    if (template.bonusQuestions && template.bonusQuestions.length > 0) {
        const bonusPartContainer = document.createElement("div");
        bonusPartContainer.style.padding = '5px';
        bonusPartContainer.style.marginBottom = '8px';
        bonusPartContainer.style.borderBottom = '1px solid #ccc';
        bonusPartContainer.id = `part-bonus-container`;

        bonusPartContainer.innerHTML = `<h2>Bonus Part</h2>`;

        const bonusSectionContainer = document.createElement('div');
        bonusSectionContainer.style.padding = '5px';
        bonusSectionContainer.style.marginBottom = '8px';
        bonusSectionContainer.style.borderBottom = '1px solid #ccc';
        bonusSectionContainer.style.backgroundColor = '#d3d3d3';
        bonusSectionContainer.id = `bonus-container`;

        bonusSectionContainer.innerHTML = `
            <h3>Bonus Section: Bonus Questions</h3>
            <button class="add-btn" onclick="openBonusQuestionModal('${isbn}')">Choose Bonus Questions</button>
            <div class="selected-questions"></div>
        `;

        // Create selectedQuestionsDiv and add bonus questions to it
        const selectedQuestionsDiv = document.createElement('div');
        
        template.bonusQuestions.forEach((questionId, questionIndex) => {
            const [type, index] = questionId.split('-');
            const question = masterQuestionList[isbn][type][index];
            
            const questionElement = document.createElement("div");
            questionElement.style.padding = "8px";
            questionElement.style.margin = "5px 0";
            questionElement.style.backgroundColor = "#f0f0f0";
            questionElement.style.borderRadius = "4px";
            questionElement.dataset.questionIndex = questionIndex; // Store original index
            questionElement.dataset.questionId = questionId; // Store the question ID

            questionElement.innerHTML = `
                <p>${question.text}</p>
                <label>Points: </label>
                <input type="number" class="question-points" min="1" value="${question.score}" style="width: 60px;" disabled>
            `;

            selectedQuestionsDiv.appendChild(questionElement);
        });

        // Find the selected-questions div and append our content
        const selectedQuestionsContainer = bonusSectionContainer.querySelector('.selected-questions');
        selectedQuestionsContainer.appendChild(selectedQuestionsDiv);

        bonusPartContainer.appendChild(bonusSectionContainer);
        test.appendChild(bonusPartContainer);
    } else {
        // Add a button to add bonus questions if none exist yet
        const bonusPartContainer = document.createElement("div");
        bonusPartContainer.style.padding = '5px';
        bonusPartContainer.style.marginBottom = '8px';
        bonusPartContainer.style.borderBottom = '1px solid #ccc';
        bonusPartContainer.id = `part-bonus-container`;

        bonusPartContainer.innerHTML = `
            <h2>Bonus Part</h2>
            <button class="add-btn" onclick="openBonusQuestionModal('${isbn}')">Add Bonus Questions</button>
        `;

        test.appendChild(bonusPartContainer);
    }
}

/**
 * This rather involved function saves the test based on all the info in the test editor.
 * Preconditions: a valid isbn, one of two save buttons pressed, a test name, a valid template
 * Postconditions: saves the test as either a draft or published test.
*/
function saveTest(isbn, isPublished, testIndex = null) {
    const testName = document.getElementById("nameField").value.trim();
    if (!testName) {
        alert("Test Name is required.");
        return;
    }

    const templateIndex = document.getElementById("templateSelector").value;
    if (!templateIndex) {
        alert("Please select a template first");
        return;
    }

    const template = masterTemplateList[isbn][templateIndex];
    
    let usedQuestions = [];

    const testData = {
        name: testName,
        template: template,
        templateName: template.name,
        templateIndex: templateIndex,
        parts: [],
        feedback: []
    };

    // Loop through all parts and sections rendered in the UI
    const testParts = document.getElementById("testParts");
    const partContainers = testParts.querySelectorAll('[id^="part-"][id$="-container"]');
    let noquestions = true;
    partContainers.forEach((partContainer, partIndex) => {
        const partData = {
            partNumber: partIndex + 1,
            sections: []
        };

        // Find all section containers within this part
        const sectionContainers = partContainer.querySelectorAll('[id^="part-' + partIndex + '-section-"]');

        sectionContainers.forEach((sectionContainer, sectionIndex) => {
            const questionType = template.partStructure[partIndex].sections[sectionIndex].questionType;
            const selectedQuestionsDiv = sectionContainer.querySelector('.selected-questions');

            // Skip sections with no questions
            if (!selectedQuestionsDiv || !selectedQuestionsDiv.children.length) {
                return;
            }

            const sectionData = {
                sectionNumber: sectionIndex + 1,
                questionType: questionType,
                questions: []
            };

            // Get all question divs (skip the first child which is the section points setter)
            const questionDivs = selectedQuestionsDiv.querySelectorAll('div[style*="border-radius"]');

            questionDivs.forEach((questionDiv) => {
                const questionIndex = questionDiv.dataset.questionIndex;
                const pointsInput = questionDiv.querySelector('.question-points');
                const points = pointsInput ? parseInt(pointsInput.value) : 1; //if there are no points, make it 1 point

                // Get the question from master list and clone it
                const question = JSON.parse(JSON.stringify(masterQuestionList[isbn][questionType.toLowerCase()][questionIndex]));

                // Update points for this clone if they were changed
                question.score = points;
                usedQuestions.push(masterQuestionList[isbn][questionType.toLowerCase()][questionIndex]);
                // Add to the questions for this section
                sectionData.questions.push(question);
                noquestions=false;
                // Set the published key to 1 if the test is published
                if (isPublished === 'true') {
                    masterQuestionList[isbn][questionType.toLowerCase()][questionIndex].published = 1;
                }
            });
            if(noquestions){
                alert("Please select questions for each section");
                return;
            }
            partData.sections.push(sectionData);
        });

        testData.parts.push(partData);
    });

    if (template.bonusSection) {
        const bonusPart = {
            partNumber: testData.parts.length + 1,
            sections: [{
                sectionNumber: 1,
                questionType: 'bonus',
                questions: template.bonusQuestions.map(q => {
                    const [type, index] = q.split('-');
                    const question = masterQuestionList[isbn][type][index];
                    if (isPublished === 'true') {
                        question.published = 1;
                    }
                    return question;
                })
            }]
        };
        testData.parts.push(bonusPart);
    }

    // Save the test data
    if (!masterTestList[isbn]) {
        masterTestList[isbn] = { drafts: [], published: [] };
    }

    const targetList = isPublished === 'true' ? masterTestList[isbn].published : masterTestList[isbn].drafts;
    if (testIndex !== null) {
        targetList[testIndex] = testData;
    } else {
        targetList.push(testData);
    }
    
    // Set the published key for the template and cover page if the test is published
    if (isPublished === 'true') {
        masterTemplateList[isbn][templateIndex].published = 1;
        const coverPageIndex = template.coverPageType;
        if (masterCoverPageList[isbn][coverPageIndex]) {
            masterCoverPageList[isbn][coverPageIndex].published = 1;
        }
    }

    usedQuestions.forEach(question => {
        question.tests.push(testData.name);
        console.log("Updated question:", question);
        console.log("Question published value:", question.published);
    });

    alert(`Test "${testName}" saved successfully as ${isPublished === 'true' ? "Published" : "Draft"}!`);
    updateTestTabs(isbn);
    closeModal();
}

/**
 * Opens up the questionModal and populates it with questions of the appropriate type. 
 * If such questions exist, creates checkboxes next to each one to be used for selecting questions.
 * Preconditions: openQuestionModal expects a valid isbn, part number, section number, and question type
 * Postconditions: opens up the question modal with questions of the appropriate type for the correct textbook
*/
function openQuestionModal(isbn, partNum, sectionNum, type) {
    const modal = document.getElementById("questionModal");
    const modalTitle = document.getElementById("questionModalTitle");
    const modalBody = document.getElementById("questionModalBody");
    
    // Check if we have questions of this type
    if (!masterQuestionList[isbn][type] || masterQuestionList[isbn][type].length === 0) {
        alert("No questions available of this type!");
        return;
    }

    const questions = masterQuestionList[isbn][type];
    modalBody.innerHTML = ""; // Clear existing content

    // Store the part/section info in the modal for later use
    modalBody.dataset.isbn = isbn;
    modalBody.dataset.partNum = partNum;
    modalBody.dataset.sectionNum = sectionNum;
    modalBody.dataset.questionType = type;

    const filterContainer = document.createElement('div');
    filterContainer.style.padding = '5px';
    filterContainer.style.marginBottom = '8px';
    filterContainer.style.borderBottom = '1px solid #ccc';

    // Filter by Test
    const testFilterLabel = document.createElement('label');
    testFilterLabel.textContent = 'Filter by Test:';
    filterContainer.appendChild(testFilterLabel);

    const testFilterSelect = document.createElement('select');
    testFilterSelect.id = 'testFilterSelect';
    testFilterSelect.innerHTML = '<option value="" selected>All Tests</option>';
    const testList = masterTestList[isbn]['drafts'].concat(masterTestList[isbn]['published']);
    testList.forEach((test, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = test.name;
        testFilterSelect.appendChild(option);
    });
    filterContainer.appendChild(testFilterSelect);
    filterContainer.appendChild(document.createElement('br'));

    // Chapter Filter
    const chapterFilterLabel = document.createElement('label');
    chapterFilterLabel.textContent = 'Filter by Chapter:';
    filterContainer.appendChild(chapterFilterLabel);

    const chapterFilterSelect = document.createElement('select');
    chapterFilterSelect.id = 'chapterFilterSelect';
    
    // Add "All Chapters" option
    const allChaptersOption = document.createElement('option');
    allChaptersOption.value = "all";
    allChaptersOption.textContent = "All Chapters";
    chapterFilterSelect.appendChild(allChaptersOption);
    
    // Get unique chapters from questions
    const chapters = [...new Set(questions.map(q => q.chapter))].sort((a, b) => a - b);
    chapters.forEach(chapter => {
        const option = document.createElement('option');
        option.value = chapter;
        option.textContent = `Chapter ${chapter}`;
        chapterFilterSelect.appendChild(option);
    });
    filterContainer.appendChild(chapterFilterSelect);
    filterContainer.appendChild(document.createElement('br'));
    
    // Section Filter (initially hidden)
    const sectionFilterContainer = document.createElement('div');
    sectionFilterContainer.id = 'sectionFilterContainer';
    sectionFilterContainer.style.display = 'none';
    sectionFilterContainer.style.marginTop = '5px';
    
    const sectionFilterLabel = document.createElement('label');
    sectionFilterLabel.textContent = 'Filter by Section:';
    sectionFilterContainer.appendChild(sectionFilterLabel);
    
    const sectionFilterSelect = document.createElement('select');
    sectionFilterSelect.id = 'sectionFilterSelect';
    sectionFilterContainer.appendChild(sectionFilterSelect);
    
    filterContainer.appendChild(sectionFilterContainer);
    modalBody.appendChild(filterContainer);

    const questionContainer = document.createElement('div');
    questionContainer.id = 'questionContainer';
    questionContainer.style.padding = '5px';
    questionContainer.style.marginBottom = '8px';
    questionContainer.style.borderBottom = '1px solid #ccc';

    // Display all questions initially
    renderQuestions(questions, questionContainer);

    const submitButton = document.createElement('button');
    submitButton.className = 'add-btn';
    submitButton.textContent = 'Add Selected Questions';
    submitButton.onclick = function() {
        addSelectedQuestions();
    };
    
    modalBody.appendChild(questionContainer);
    modalBody.appendChild(submitButton);

    modalTitle.innerText = `Select ${type.toUpperCase()} Questions`;

    modal.style.display = "flex";
    setTimeout(() => {
        modal.style.opacity = "1";
    }, 10);

    // Add event listeners for filters
    testFilterSelect.addEventListener('change', () => filterQuestions(isbn, type));
    
    // Chapter filter change event
    chapterFilterSelect.addEventListener('change', function() {
        const selectedChapter = this.value;
        const sectionContainer = document.getElementById('sectionFilterContainer');
        const sectionSelect = document.getElementById('sectionFilterSelect');
        
        // Clear and hide section filter if "All Chapters" is selected
        if (selectedChapter === "all") {
            sectionContainer.style.display = 'none';
            sectionSelect.innerHTML = '';
        } else {
            // Show section filter and populate with sections from selected chapter
            sectionContainer.style.display = 'block';
            
            // Clear existing options
            sectionSelect.innerHTML = '';
            
            // Add "All Sections" option
            const allSectionsOption = document.createElement('option');
            allSectionsOption.value = "all";
            allSectionsOption.textContent = "All Sections";
            sectionSelect.appendChild(allSectionsOption);
            
            // Get unique sections for the selected chapter
            const sectionsInChapter = [...new Set(
                questions
                .filter(q => q.chapter == selectedChapter)
                .map(q => q.section)
            )].sort((a, b) => a - b);
            
            sectionsInChapter.forEach(section => {
                const option = document.createElement('option');
                option.value = section;
                option.textContent = `Section ${section}`;
                sectionSelect.appendChild(option);
            });
        }
        
        // Apply filters
        filterQuestions(isbn, type);
    });
    
    // Section filter change event
    document.getElementById('sectionFilterSelect').addEventListener('change', () => {
        filterQuestions(isbn, type);
    });
}

// Helper function to render questions
function renderQuestions(questions, container) {
    container.innerHTML = '';
    
    if (questions.length === 0) {
        const noQuestionsMsg = document.createElement('p');
        noQuestionsMsg.textContent = 'No questions match the selected filters.';
        container.appendChild(noQuestionsMsg);
        return;
    }
    
    questions.forEach((question, index) => {
        const element = document.createElement("div");
        element.style.padding = '8px';
        element.style.margin = '5px 0';
        element.style.backgroundColor = '#f0f0f0';
        element.style.borderRadius = '4px';
        element.innerHTML = `
            <input type="checkbox" id="q-${index}" value="${index}">
            <label for="q-${index}">${question.text} (${question.score} Points) - Ch.${question.chapter}, Sec.${question.section}</label>
        `;   
        container.appendChild(element);
    });
}

// Function to filter questions based on selected filters
function filterQuestions(isbn, type) {
    const questions = masterQuestionList[isbn][type];
    const testFilterValue = document.getElementById('testFilterSelect').value;
    const chapterFilterValue = document.getElementById('chapterFilterSelect').value;
    const sectionFilterSelect = document.getElementById('sectionFilterSelect');
    const sectionFilterValue = sectionFilterSelect && sectionFilterSelect.style.display !== 'none' ? 
                               sectionFilterSelect.value : "all";
    
    // Create a filtered index map to maintain original indices
    const filteredIndices = [];
    const filteredQuestions = [];
    
    questions.forEach((question, index) => {
        let includeQuestion = true;
        
        // Apply test filter if selected
        if (testFilterValue !== "") {
            const testIndex = parseInt(testFilterValue);
            const testList = masterTestList[isbn]['drafts'].concat(masterTestList[isbn]['published']);
            const testQuestionIds = testList[testIndex].questions.map(q => q.id);
            if (!testQuestionIds.includes(question.id)) {
                includeQuestion = false;
            }
        }
        
        // Apply chapter filter if selected
        if (chapterFilterValue !== "all" && question.chapter != chapterFilterValue) {
            includeQuestion = false;
        }
        
        // Apply section filter if visible and selected
        if (chapterFilterValue !== "all" && sectionFilterValue !== "all" && 
            question.section != sectionFilterValue) {
            includeQuestion = false;
        }
        
        if (includeQuestion) {
            filteredIndices.push(index);
            filteredQuestions.push(question);
        }
    });
    
    // Render filtered questions while preserving original indices
    const questionContainer = document.getElementById('questionContainer');
    questionContainer.innerHTML = '';
    
    if (filteredQuestions.length === 0) {
        const noQuestionsMsg = document.createElement('p');
        noQuestionsMsg.textContent = 'No questions match the selected filters.';
        questionContainer.appendChild(noQuestionsMsg);
        return;
    }
    
    filteredQuestions.forEach((question, i) => {
        const originalIndex = filteredIndices[i];
        const element = document.createElement("div");
        element.style.padding = '8px';
        element.style.margin = '5px 0';
        element.style.backgroundColor = '#f0f0f0';
        element.style.borderRadius = '4px';
        element.innerHTML = `
            <input type="checkbox" id="q-${originalIndex}" value="${originalIndex}">
            <label for="q-${originalIndex}">${question.text} (${question.score} Points) - Ch.${question.chapter}, Sec.${question.section}</label>
        `;   
        questionContainer.appendChild(element);
    });
}

/**
 * This adds the questions selected in the questionModal to the test editor.
 * It uses data included in the modalBody using the dataset property from HTMLElement
 * Preconditions: all data requested from dataset is entered in the modalBody
 * Postcondition: returns to test editor with all of the questions added
*/
function addSelectedQuestions() {
    const modalBody = document.getElementById("questionModalBody");
    const isbn = modalBody.dataset.isbn;
    const partNum = parseInt(modalBody.dataset.partNum);
    const sectionNum = parseInt(modalBody.dataset.sectionNum);
    const type = modalBody.dataset.questionType;
    
    //find all of the checkbox type inputs in the questionModalBody element and selected by the user
    const checkboxes = document.querySelectorAll('#questionModalBody input[type="checkbox"]:checked');
    //returns an array of selected question IDs
    
    if (checkboxes.length === 0) {
        alert("Please select at least one question.");
        return;
    }
    
    const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));
    const questions = selectedIndices.map(index => masterQuestionList[isbn][type][index]);
    
    // Update the test part on screen
    const sectionContainer = document.getElementById(`part-${partNum}-section-${sectionNum}-container`);
    const selectedQuestionsDiv = sectionContainer.querySelector('.selected-questions');
    selectedQuestionsDiv.innerHTML = '';
    
    // Create a section-wide point value input
    const sectionPointsDiv = document.createElement("div");
    sectionPointsDiv.innerHTML = `
        <label>Set All Points for This Section: </label>
        <input type="number" id="section-${partNum}-${sectionNum}-points" min="1" value="1" style="width: 60px;">
        <button onclick="updateSectionPoints(${partNum}, ${sectionNum})">Apply</button>
        <hr>
    `;
    selectedQuestionsDiv.appendChild(sectionPointsDiv);

    // Add each selected question to the section
    questions.forEach((question, index) => {
        const questionElement = document.createElement("div");
        questionElement.style.padding = "8px";
        questionElement.style.margin = "5px 0";
        questionElement.style.backgroundColor = "#f0f0f0";
        questionElement.style.borderRadius = "4px";
        questionElement.dataset.questionIndex = selectedIndices[index]; // Store original index

        questionElement.innerHTML = `
            <p>${question.text}</p>
            <label>Points: </label>
            <input type="number" class="question-points" min="1" value="${question.score}" style="width: 60px;">
        `;

        selectedQuestionsDiv.appendChild(questionElement);
    });

    const randomizer = document.createElement("button");
    randomizer.className = "add-btn";
    randomizer.textContent = "Randomize Question Order";
    randomizer.onclick = function() {
        const questionElements = Array.from(selectedQuestionsDiv.children).slice(1); // Skip the first child
        ShuffleArray(questionElements);
        selectedQuestionsDiv.innerHTML = ''; 
        selectedQuestionsDiv.appendChild(sectionPointsDiv);
        questionElements.forEach((element, index) => {
            selectedQuestionsDiv.appendChild(element);
        });
    };
    selectedQuestionsDiv.appendChild(randomizer);

    alert(`Added ${questions.length} questions to Part ${partNum + 1}, Section ${sectionNum + 1}`);

    closeQuestionModal();
}

function ShuffleArray(questionElements){
    for (let i = questionElements.length - 2; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [questionElements[i], questionElements[j]] = [questionElements[j], questionElements[i]];
    }
}


/**
 * This code is for the test editor. It updates the points for every question inside a section,
 * when the button is pressed for that section. This function grabs the section-X-Y-points value
 * where X is the part number and Y is the section number. This points to a numeric field that allows selection
 * of different point values per section. 
 * It takes the value from that selection and applies it to all of the elements whose IDs include question-points
 * Precondition: valid part and section number, test editor open and functional
 * Postcondition: All question point values in the section will be updated to the new value
*/
function updateSectionPoints(partNum, sectionNum) {
    const newPointValue = document.getElementById(`section-${partNum}-${sectionNum}-points`).value;

    if (!newPointValue || newPointValue < 1) {
        alert("Please enter a valid point value.");
        return;
    }

    // Select all question inputs in this section
    const sectionContainer = document.getElementById(`part-${partNum}-section-${sectionNum}-container`);
    const pointInputs = sectionContainer.querySelectorAll('.question-points');

    pointInputs.forEach(input => {
        input.value = newPointValue;
    });

    alert(`Updated all questions in Part ${partNum + 1}, Section ${sectionNum + 1} to ${newPointValue} points each.`);
}



/**
 * This triggers whenever reloading or exiting the page/tab, and gives a warning 
 * that some of the data may not be saved.
 * Precondition: NA
 * Postcondition: Warning message displayed
*/
window.onbeforeunload = function(event){
    event.returnValue = "Warning! Data entered may not be saved!";
};

/**
 * This gets the editModal and makes it invisible and impossible to interact with
 * Precondition: This assumes the questionModal has a display other than none (likely flex) 
 * Be careful not to mix this up with closeQuestionModal, as the two modals are separate and designed to be able to exist simultaneously
 */
function closeModal() {
    document.getElementById("editModal").style.display = "none";
    document.getElementById("editModal").style.opacity = "0";
}

/**
 * This gets the questionModal and makes it invisible and impossible to interact with
 * Precondition: This assumes the questionModal has a display other than none (likely flex)
*/
function closeQuestionModal(){
    document.getElementById("questionModal").style.display = "none";
    document.getElementById("questionModal").style.opacity = "0";
}


/**
 * Opens up a context menu on right click when the user is on a context-menu-target element.
 * This context menu is used to edit or delete items, or to add/view feedback for questions and tests.
 * Precondition: context-menu-target element 
 * Postcondition: context menu is displayed with options to edit or delete the item
*/
document.addEventListener('contextmenu', function (event) {
    const target = event.target.closest('.context-menu-target');
    if (target) {
        event.preventDefault();
        const contextMenu = document.getElementById('contextMenu');
        contextMenu.style.top = `${event.clientY}px`;
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.display = 'block';

        // Store the relevant data in the context menu for later use
        contextMenu.dataset.itemType = target.dataset.itemType;
        contextMenu.dataset.itemIndex = target.dataset.itemIndex;
        contextMenu.dataset.isbn = target.dataset.isbn;
        contextMenu.dataset.questionType = target.dataset.questionType;
        contextMenu.dataset.testType = target.dataset.testType;

        console.log(`Context menu opened for target:`, target);
    } else {
        const contextMenu = document.getElementById('contextMenu');
        contextMenu.style.display = 'none';
    }
});

/**
 * This closes the context menu when the user clicks anywhere on the document.
 * Precondition: context menu is open
 * Postcondition: context menu is closed
*/
document.addEventListener('click', function () {
    const contextMenu = document.getElementById('contextMenu');
    contextMenu.style.display = 'none';
});

/**
 * This function is called when the user clicks the edit button in the context menu.
 * It determines the type of item being edited and calls the appropriate edit function.
 * Precondition: context menu is open, edit button is clicked
 * Postcondition: edit modal is opened with the appropriate item data
*/
function editItem() {
    const contextMenu = document.getElementById('contextMenu');
    const itemType = contextMenu.dataset.itemType;
    const itemIndex = contextMenu.dataset.itemIndex;
    const isbn = contextMenu.dataset.isbn;
    const questionType = contextMenu.dataset.questionType;

    switch (itemType) {
        case 'question':
            editQuestion(isbn, questionType, itemIndex);
            break;
        case 'coverPage':
            editCoverPage(isbn, itemIndex);
            break;
        case 'template':
            editTemplate(isbn, itemIndex);
            break;
        case 'test':
            if(contextMenu.dataset.testType === 'published'){
                alert("You cannot edit published tests.");
                return;
            }
            editTest(isbn, itemIndex);
            break;
        case 'attachment':
            editAttachment(isbn, itemIndex);
            break;
        default:
            console.error('Unknown item type:', itemType);
    }
}

/**
 * This function is called when the user clicks the delete button in the context menu.
 * It determines the type of item being deleted and calls the appropriate delete function.
 * Precondition: context menu is open, delete button is clicked, and is not published
 * Postcondition: item is deleted from the master list, if it is not published
*/
function deleteItem() {
    const contextMenu = document.getElementById('contextMenu');
    const itemType = contextMenu.dataset.itemType;
    const itemIndex = contextMenu.dataset.itemIndex;
    const isbn = contextMenu.dataset.isbn;
    const questionType = contextMenu.dataset.questionType;

    switch (itemType) {
        case 'question':
            deleteQuestion(isbn, questionType, itemIndex);
            break;
        case 'coverPage':
            deleteCoverPage(isbn, itemIndex);
            break;
        case 'template':
            deleteTemplate(isbn, itemIndex);
            break;
        case 'test':
            if(contextMenu.dataset.testType === 'published'){
                alert("You cannot delete published tests.");
                return;
            }
            deleteTest(isbn, itemIndex);
            break;
        case 'attachment':
            deleteAttachment(isbn, itemIndex);
            break;
        default:
            console.error('Unknown item type:', itemType);
    }
}

/**
 * This function is called when the user clicks the edit button for a question in the context menu.
 * It will allow the editing of published questions, but only after a confirmation dialog.
 * Precondition: context menu is open, edit button is clicked
 * Postcondition: edit modal is opened with the appropriate question data
*/
function editQuestion(isbn, questionType, questionIndex) {
    if(masterQuestionList[isbn][questionType][questionIndex].published === 1){
        if(!confirm("This question is published. Are you sure you want to edit it?")){
           return;
        }
    }
    const question = masterQuestionList[isbn][questionType][questionIndex];

    // Open the edit modal and populate it with the question data
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'Edit Question';

    let formContent = `
        <label>Question:</label><br/>
        <textarea id="editQuestionField" rows="5">${question.text}</textarea><br><br>
    `;

    if (questionType === 'tf') {
        formContent += `
            <label>Correct Answer:</label><br/>
            <select id="editAnswerField">
                <option value="true" ${question.answer === 'true' ? 'selected' : ''}>True</option>
                <option value="false" ${question.answer === 'false' ? 'selected' : ''}>False</option>
            </select><br><br>
        `;
    } else if (questionType === 'sa' || questionType === 'es') {
        formContent += `
            <label>Correct Answer:</label><br/>
            <textarea id="editAnswerField" rows="4">${question.answer}</textarea><br><br>
        `;
    } else if (questionType === 'mc') {
        formContent += `
            <label>Options:</label><br/>
            <input type="text" id="editOptionA" value="${question.options[0]}" placeholder="Option A"><br>
            <input type="text" id="editOptionB" value="${question.options[1]}" placeholder="Option B"><br>
            <input type="text" id="editOptionC" value="${question.options[2]}" placeholder="Option C"><br>
            <input type="text" id="editOptionD" value="${question.options[3]}" placeholder="Option D"><br><br>
            <label>Correct Answer:</label><br/>
            <select id="editAnswerField">
                <option value="A" ${question.answer === 'A' ? 'selected' : ''}>A</option>
                <option value="B" ${question.answer === 'B' ? 'selected' : ''}>B</option>
                <option value="C" ${question.answer === 'C' ? 'selected' : ''}>C</option>
                <option value="D" ${question.answer === 'D' ? 'selected' : ''}>D</option>
            </select><br><br>
        `;
    } else if (questionType === 'ma') {
        formContent += `
            <label>Number of Options:</label><br/>
            <input type="number" id="editNumOptions" value="${question.options.length}" min="2" step="2" onchange="updateEditOptions('${questionType}')"><br><br>
            <div id="editOptionsContainer"></div>
        `;
        setTimeout(() => updateEditOptions(questionType, question.options), 50);
    } else if (questionType === 'ms') {
        formContent += `
            <label>Number of Options:</label><br/>
            <input type="number" id="editNumOptions" value="${question.options.length}" min="1" max="20" onchange="updateEditOptions('${questionType}')"><br><br>
            <div id="editOptionsContainer"></div>
        `;
        setTimeout(() => updateEditOptions(questionType, question.options, question.answer), 50);
    } else if (questionType === 'fb') {
        formContent += `
            <label>Number of Blanks:</label><br/>
            <input type="number" id="editNumBlanks" value="${question.answer.length}" min="1" onchange="updateEditOptions('${questionType}')"><br><br>
            <div id="editOptionsContainer"></div>
            <label>Include Formula:</label>
            <input type="checkbox" id="editIncludeFormula" ${question.answer.some(a => a.formula) ? 'checked' : ''} onchange="toggleEditFormulaInput()"><br><br>
            <div id="editFormulaContainer"></div>
        `;
        setTimeout(() => updateEditOptions(questionType, question.answer), 50);
    }

    formContent += `
        <label>Point Value:</label><br/>
        <input type="number" id="editPointValueField" min="1" value="${question.score}"><br><br>
        <label>Chapter: </label><br/>  
        <input type="number" id="editChapterField" min="1" value="${question.chapter}"><br><br>
        <label>Section: </label><br/>
        <input type="number" id="editSectionField" min="1" value="${question.section}"><br><br>
        <label>Estimated Time:</label><br/>
        <input type="number" id="editTimeField" min="1" value="${question.eta}"><br><br>
        <label>Reference Text:</label><br/>
        <textarea id="editRefField" rows="4">${question.reference}</textarea><br><br>
        <label>Question Image:</label><br/>
        <select id="editGraphicField">
            <option value="" disabled selected>Select a graphic</option>
        </select><br><br>
        <label>Answer Image:</label><br/>
        <select id="editAnsGraphicField">
            <option value="" disabled selected>Select a graphic</option>
        </select><br><br>
        <label>Instructor Comment:</label><br/>
        <textarea id="editInstructorCommentField" rows="4">${question.comments}</textarea><br><br>
        <label>Grading Instructions:</label><br/>
        <textarea id="editInstructionField" rows="6">${question.directions}</textarea><br><br>
        <button class="add-btn" onclick="submitEditQuestion('${isbn}', '${questionType}', ${questionIndex})">Submit Edit</button>
    `;

    modalBody.innerHTML = formContent;
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);

    // Populate the graphic selectors
    updateEditGraphicSelectors(isbn, question);
}

/**
 * This function updates the graphics fields in the editor modal with the available graphics for the textbook.
 * This version of the function is used when the user is editing a question
 * Precondition: valid isbn and question, attachments exist in the textbook attachment list
 * Postcondition: graphics fields are updated with the available graphics for the textbook in the edit modal
*/
function updateEditGraphicSelectors(isbn, question) {
    const qGraphicField = document.getElementById('editGraphicField');
    const ansGraphicField = document.getElementById('editAnsGraphicField');

    qGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';
    ansGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';

    if (!masterAttachmentList[isbn] || masterAttachmentList[isbn].length === 0) {
        alert("No attachments available for this textbook!");
        return;
    }

    masterAttachmentList[isbn].forEach((attachment, index) => {
        const option = document.createElement('option');
        option.value = attachment.name;
        option.textContent = attachment.name;
        qGraphicField.appendChild(option);

        const ansOption = document.createElement('option');
        ansOption.value = attachment.name;
        ansOption.textContent = attachment.name;
        ansGraphicField.appendChild(ansOption);
    });

    // Set the current selection
    qGraphicField.value = question.graphic;
    ansGraphicField.value = question.ansGraphic;
}

/**
 * This function is called to update the graphics fields in the editor modal with the available graphics for the textbook.
 * This version of the function is used when the user is first creating a question.
 * Precondition: valid isbn, attachments exist in the textbook attachment list
 * Postcondition: graphics fields are updated with the available graphics for the textbook in the edit modal
*/
function updateGraphicSelectors(isbn) {
    const qGraphicField = document.getElementById('qGraphicField');
    const ansGraphicField = document.getElementById('ansGraphicField');

    qGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';
    ansGraphicField.innerHTML = '<option value="" disabled selected>Select a graphic</option>';

    if (!masterAttachmentList[isbn] || masterAttachmentList[isbn].length === 0) {
        alert("No attachments available for this textbook!");
        return;
    }

    masterAttachmentList[isbn].forEach((attachment, index) => {
        const option = document.createElement('option');
        option.value = attachment.name;
        option.textContent = attachment.name;
        qGraphicField.appendChild(option);

        const ansOption = document.createElement('option');
        ansOption.value = attachment.name;
        ansOption.textContent = attachment.name;
        ansGraphicField.appendChild(ansOption);
    });
}

/**
 * This function is used to update the possible options for a question in the editor modal during question editing. 
 * It updates the possible options and answers for a question based on question type, similar to the options during question creation.
 * Precondition: valid question type, options, and answers  
 * Postcondition: options and answers are updated in the editor modal
*/
function updateEditOptions(type, options = [], answers = []) {
    const optionsContainer = document.getElementById('editOptionsContainer');
    optionsContainer.innerHTML = '';

    if (type === 'ma') {
        const numOptions = parseInt(document.getElementById('editNumOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            optionsContainer.innerHTML += `
                <label>Option ${i}:</label><br/>
                <input type="text" id="editOption${i}" value="${options[i - 1] || ''}" placeholder="Option ${i}"><br><br>
            `;
        }
    } else if (type === 'ms') {
        const numOptions = parseInt(document.getElementById('editNumOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            optionsContainer.innerHTML += `
                <label>Option ${i}:</label><br/>
                <input type="text" id="editOption${i}" value="${options[i - 1] || ''}" placeholder="Option ${i}"><br>
                <label>Correct Answer:</label>
                <input type="checkbox" id="editCorrect${i}" ${answers.includes(options[i - 1]) ? 'checked' : ''}><br><br>
            `;
        }
    } else if (type === 'fb') {
        const numBlanks = parseInt(document.getElementById('editNumBlanks').value);
        for (let i = 1; i <= numBlanks; i++) {
            optionsContainer.innerHTML += `
                <label>Answer for Blank ${i}:</label><br/>
                <input type="text" id="editBlank${i}" value="${options[i - 1] || ''}" placeholder="Answer for Blank ${i}"><br><br>
            `;
        }
        if (document.getElementById('editIncludeFormula').checked) {
            document.getElementById('editFormulaContainer').innerHTML = `
                <label>Formula:</label><br/>
                <input type="text" id="editFormulaField" value="${options.find(a => a.formula)?.formula || ''}" placeholder="Enter the formula here..."><br><br>
            `;
        }
    }
}

/**
 * This function determines whether or not a formula input checkbox is available when editing a question.
 * It is activated by fill in the blank questions for now, but will likely be moved to numeric type questions (TODO: add numeric questions)
 * Precondition: checked formula toggle
 * Postcondition: formula input is displayed or hidden based on the checkbox
*/
function toggleEditFormulaInput() {
    const includeFormula = document.getElementById('editIncludeFormula').checked;
    const formulaContainer = document.getElementById('editFormulaContainer');
    if (includeFormula) {
        formulaContainer.innerHTML = `
            <label>Formula:</label><br/>
            <input type="text" id="editFormulaField" placeholder="Enter the formula here..."><br><br>
        `;
    } else {
        formulaContainer.innerHTML = '';
    }
}

/**
 * This function is called when the user submits an edited question in the editor modal.
 * It updates the question in the master question list with the new data.
 * Precondition: valid isbn, question type, and question index
 * Postcondition: question is updated in the master question list or a clone is created
 * RECENTLY EDITED
*/
function submitEditQuestion(isbn, questionType, questionIndex) {
    const text = document.getElementById('editQuestionField').value.trim();
    const score = document.getElementById('editPointValueField').value.trim();
    const reference = document.getElementById('editRefField').value.trim();
    const time = document.getElementById('editTimeField').value.trim();
    const graphic = document.getElementById('editGraphicField').value;
    const ansGraphic = document.getElementById('editAnsGraphicField').value;
    const comments = document.getElementById('editInstructorCommentField').value.trim();
    const directions = document.getElementById('editInstructionField').value.trim();
    const chapter = document.getElementById('editChapterField').value.trim();
    const section = document.getElementById('editSectionField').value.trim();   

    if (!text || !score || !directions || !time || !chapter || !section) {
        alert("Some fields are required. (Prompt, Point Value, Directions, Time, Chapter, Section)");
        return;
    }

    let answer = '';
    let options = [];

    if (questionType === 'tf') {
        answer = document.getElementById('editAnswerField').value;
    } else if (questionType === 'sa' || questionType === 'es') {
        answer = document.getElementById('editAnswerField').value.trim();
    } else if (questionType === 'mc') {
        options = [
            document.getElementById('editOptionA').value.trim(),
            document.getElementById('editOptionB').value.trim(),
            document.getElementById('editOptionC').value.trim(),
            document.getElementById('editOptionD').value.trim()
        ];
        answer = document.getElementById('editAnswerField').value;
    } else if (questionType === 'ma') {
        const numOptions = parseInt(document.getElementById('editNumOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            options.push(document.getElementById(`editOption${i}`).value.trim());
        }
        answer = [];
        for (let i = 1; i <= numOptions / 2; i++) {
            const prompt = document.getElementById(`editOption${i}`).value.trim();
            const match = document.getElementById(`editOption${i + numOptions / 2}`).value.trim();
            answer.push({ prompt: prompt, match: match });
        }
    } else if (questionType === 'ms') {
        const numOptions = parseInt(document.getElementById('editNumOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            options.push(document.getElementById(`editOption${i}`).value.trim());
            if (document.getElementById(`editCorrect${i}`).checked) {
                answer.push(document.getElementById(`editOption${i}`).value.trim());
            }
        }
    } else if (questionType === 'fb') {
        const numBlanks = parseInt(document.getElementById('editNumBlanks').value);
        for (let i = 1; i <= numBlanks; i++) {
            answer.push(document.getElementById(`editBlank${i}`).value.trim());
        }
        if (document.getElementById('editIncludeFormula').checked) {
            answer.push({ formula: document.getElementById('editFormulaField').value.trim() });
        }
    }

    
    const question = masterQuestionList[isbn][questionType][questionIndex];
    if(question.published===1){
        if(confirm("Are you sure you want to edit a published question? If you would rather clone this question, click okay.")){
            let clone = {
                text: text,
                answer: answer,
                score: score,
                directions: directions,
                time: time,
                reference: reference,
                graphic: graphic,
                ansGraphic: ansGraphic,
                comments: comments,
                options: options,
                chapter: chapter,
                section: section,
                published: 0
            }
            masterQuestionList[isbn][questionType].push(clone);
            updateQuestionTabs(questionType, isbn);
            closeModal();
            alert("Question cloned successfully!");
            return;
        }else if (confirm("Are you sure you want to edit a published question?")){
            question.text = text;
            question.answer = answer;
            question.score = score;
            question.directions = directions;
            question.time = time;
            question.reference = reference;
            question.graphic = graphic;
            question.ansGraphic = ansGraphic;
            question.comments = comments;
            question.options = options;
            question.chapter = chapter;
            question.section = section;
        }else{
            alert("Question not edited.");
            return;
        }
    }
    

    updateQuestionTabs(questionType, isbn);
    closeModal();
    alert("Question edited successfully!");
}

/**
 * This function is called to update the test content inside of the test containers whenever a test is saved
 * Precondition: valid isbn
 * Postcondition: test content is updated in the test containers    
*/
function updateTestTabs(isbn) {
    const draftsContainer = document.getElementById(`drafts-${isbn}`);
    const publishedContainer = document.getElementById(`published-${isbn}`);
    draftsContainer.innerHTML = ''; // Clear existing content
    publishedContainer.innerHTML = ''; // Clear existing content

    const drafts = masterTestList[isbn].drafts;
    const published = masterTestList[isbn].published;

    if (drafts.length === 0) {
        draftsContainer.innerHTML = '<p>No drafts available...</p>';
    } else {
        drafts.forEach((test, index) => {
            const testDiv = document.createElement('div');
            testDiv.style.backgroundColor = '#d0d0d0';
            testDiv.style.padding = '5px';
            testDiv.style.marginBottom = '8px';
            testDiv.style.borderBottom = '1px solid #ccc';
            testDiv.classList.add('context-menu-target');
            testDiv.dataset.itemType = 'test';
            testDiv.dataset.itemIndex = index;
            testDiv.dataset.isbn = isbn;
            testDiv.dataset.testType = 'draft';

            testDiv.innerHTML = `
                <p><strong>${test.name}</strong></p>
                <p>Template: ${test.templateName}</p>
                <p>Parts: ${test.parts.length - 2}</p>
            `;

            draftsContainer.appendChild(testDiv);
        });
    }

    if (published.length === 0) {
        publishedContainer.innerHTML = '<p>No published tests available...</p>';
    } else {
        published.forEach((test, index) => {
            const testDiv = document.createElement('div');
            testDiv.style.backgroundColor = '#d0d0d0';
            testDiv.style.padding = '5px';
            testDiv.style.marginBottom = '8px';
            testDiv.style.borderBottom = '1px solid #ccc';
            testDiv.classList.add('context-menu-target');
            testDiv.dataset.itemType = 'test';
            testDiv.dataset.itemIndex = index;
            testDiv.dataset.isbn = isbn;
            testDiv.dataset.testType = 'published';

            testDiv.innerHTML = `
                <p><strong>${test.name}</strong></p>
                <p>Template: ${test.templateName}</p>
                <p>Parts: ${test.parts.length}</p>
            `;

            publishedContainer.appendChild(testDiv);
        });
    }
}

/**
 * This function is called to update the question content inside the question containers whenever a question is saved
 * Precondition: valid questionType, isbn
 * Postcondition: question content is updated in the question containers
*/
function updateQuestionTabs(questionType, isbn) {
    const tabContent = document.getElementById(`${questionType}-${isbn}`);
    tabContent.innerHTML = ''; // Clear existing content

    const questions = masterQuestionList[isbn][questionType];

    if (questions.length === 0) {
        tabContent.innerHTML = `<p>No ${questionType.toUpperCase()} questions available...</p>`;
    } else {
        questions.forEach((question, index) => {
            const questionDiv = document.createElement('div');
            questionDiv.style.backgroundColor = '#d0d0d0';
            questionDiv.style.padding = '5px';
            questionDiv.style.marginBottom = '8px';
            questionDiv.style.borderBottom = '1px solid #ccc';
            questionDiv.classList.add('context-menu-target');
            questionDiv.dataset.itemType = 'question';
            questionDiv.dataset.itemIndex = index;
            questionDiv.dataset.isbn = isbn;
            questionDiv.dataset.questionType = questionType;

            questionDiv.innerHTML = `
                <p><strong>${question.text}</strong></p>
                <p>Points: ${question.score}</p>
                <p>Estimated Time: ${question.eta} minutes</p>
            `;

            tabContent.appendChild(questionDiv);
        });
    }
}

/**
 * This function deletes a selected question when chosen from the master list
 * Precondition: valid isbn, questionType, questionIndex, not published
 * Postcondition: question is deleted from the master list
*/
function deleteQuestion(isbn, questionType, questionIndex) {
    if(masterQuestionList[isbn][questionType][questionIndex].published === 1){
        alert("This question is published and cannot be deleted.");
        return;
    }
    if (confirm("Are you sure you want to delete this question? This action cannot be undone.")) {
        masterQuestionList[isbn][questionType].splice(questionIndex, 1);
        updateQuestionTabs(questionType, isbn);
        alert("Question deleted successfully!");
    }
}

/**
 * This function edits the cover page that was previously saved. 
 * Precondition: valid isbn, pageIndex
 * Postcondition: cover page is edited and republished in the master list
*/
function editCoverPage(isbn, pageIndex) {
    const coverPage = masterCoverPageList[isbn][pageIndex];

    // Open the edit modal and populate it with the cover page data
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'Edit Cover Page';

    const formContent = `
        <label>Cover Page Name:</label><br/>
        <input type="text" id="editCoverPageName" value="${coverPage.name}"><br><br>
        <label>Test Number:</label><br/>
        <input type="number" id="editTestNumber" value="${coverPage.testNum}"><br><br>
        <label>Test Date:</label><br/>
        <input type="date" id="editTestDate" value="${coverPage.date}"><br><br>
        <label>Filename:</label><br/>
        <input type="text" id="editFilename" value="${coverPage.file}"><br><br>
        <label>Show Filename:</label><br/>
        <input type="checkbox" id="editShowFilename" ${coverPage.showFilename ? 'checked' : ''}><br><br>
        <label>Student Name Location:</label><br/>
        <select id="editNameBlankSelector">
            <option value="TR" ${coverPage.blank === 'TR' ? 'selected' : ''}>Top Right</option>
            <option value="TL" ${coverPage.blank === 'TL' ? 'selected' : ''}>Top Left</option>
            <option value="BT" ${coverPage.blank === 'BT' ? 'selected' : ''}>Below the Title</option>
        </select><br><br>
        <label>Grading Instructions:</label><br/>
        <textarea id="editInstructions" rows="6">${coverPage.instructions}</textarea><br><br>
        <button class="add-btn" onclick="submitEditCoverPage('${isbn}', ${pageIndex})">Submit Edit</button>
    `;

    modalBody.innerHTML = formContent;
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This function is called to delete a cover page from the master list
 * Precondition: valid isbn, pageIndex, not published
 * Postcondition: cover page is deleted from the master list
*/
function deleteCoverPage(isbn, pageIndex) {
    if(masterCoverPageList[isbn][pageIndex].published === 1){
        alert("This cover page is published and cannot be deleted.");
        return;
    }
    if (confirm("Are you sure you want to delete this cover page? This action cannot be undone.")) {
        masterCoverPageList[isbn].splice(pageIndex, 1);
        updateCoverPages(isbn);
        alert("Cover page deleted successfully!");
    }
}

/**
 * This function is called to update the coverpage options inside any template editor
 * Precondition: valid isbn
 * Postcondition: cover page options are updated in the template editor
*/
function updateCoverPages(isbn) {
    const coverPageContainer = document.getElementById(`coverpages-${isbn}`);
    coverPageContainer.innerHTML = ''; // Clear existing content

    if (!masterCoverPageList[isbn] || masterCoverPageList[isbn].length === 0) {
        coverPageContainer.innerHTML = '<p>You have not added any cover pages yet...</p>';
        return;
    }

    masterCoverPageList[isbn].forEach((coverPage, index) => {
        const coverPageDiv = document.createElement('div');
        coverPageDiv.style.backgroundColor = '#d0d0d0';
        coverPageDiv.style.padding = '5px';
        coverPageDiv.style.marginBottom = '8px';
        coverPageDiv.style.borderBottom = '1px solid #ccc';
        coverPageDiv.classList.add('context-menu-target');
        coverPageDiv.dataset.itemType = 'coverPage';
        coverPageDiv.dataset.itemIndex = index;
        coverPageDiv.dataset.isbn = isbn;

        coverPageDiv.innerHTML = `
            <p><strong>${coverPage.name}</strong> (Test Number: ${coverPage.testNum}, Date: ${coverPage.date})</p>
            <p>Filename: ${coverPage.file}</p>
            <p>Grading Instructions: ${coverPage.instructions}</p>
        `;

        coverPageContainer.appendChild(coverPageDiv);
    });
}

/**
 * This function updates the templates inside of the template container UI when a template is saved/edited
 * Precondition: valid isbn
 * Postcondition: templates are updated in the template container
*/
function updateTemplates(isbn) {
    const templateContainer = document.getElementById(`templates-${isbn}`);
    templateContainer.innerHTML = ''; // Clear existing content

    if (!masterTemplateList[isbn] || masterTemplateList[isbn].length === 0) {
        templateContainer.innerHTML = '<p>You have not added any templates yet...</p>';
        return;
    }

    masterTemplateList[isbn].forEach((template, index) => {
        const templateDiv = document.createElement('div');
        templateDiv.style.backgroundColor = '#d0d0d0';
        templateDiv.style.padding = '5px';
        templateDiv.style.marginBottom = '8px';
        templateDiv.style.borderBottom = '1px solid #ccc';
        templateDiv.classList.add('context-menu-target');
        templateDiv.dataset.itemType = 'template';
        templateDiv.dataset.itemIndex = index;
        templateDiv.dataset.isbn = isbn;

        templateDiv.innerHTML = `
            <p><strong>${template.name}</strong></p>
        `;

        templateContainer.appendChild(templateDiv);
    });
}

/**
 * This function is called from the context menu to edit an existing template from the textbook UI
 * Precondition: valid isbn, templateIndex, not published
 * Postcondition: template is edited and saved in the master list
*/
function editTemplate(isbn, templateIndex) {
    const template = masterTemplateList[isbn][templateIndex];

    // Open the edit modal and populate it with the template data
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'Edit Template';
    if(template.published === 1){
        alert("This template is published. You cannot edit it.");
        return;
    }
    let coverPageIndex = 0;
    if(!template.coverPageType){
        coverPageType = 0;
    }else{
        coverPageType = template.coverPageType;
    }

    const formContent = `
        <div style="background:#e0e0e0;padding:20px;" id="templateEditor"> 
            <h1>Font Settings</h1>
            <label>Title Font and Font Size:</label><br/>
            <select id="titleFont">
                <option value="Times New Roman" ${template.titleFont === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                <option value="Arial" ${template.titleFont === 'Arial' ? 'selected' : ''}>Arial</option>
                <option value="Calibri" ${template.titleFont === 'Calibri' ? 'selected' : ''}>Calibri</option>
                <option value="Helvetica" ${template.titleFont === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Georgia" ${template.titleFont === 'Georgia' ? 'selected' : ''}>Georgia</option>
                <option value="Cambria" ${template.titleFont === 'Cambria' ? 'selected' : ''}>Cambria</option>
                <option value="Garamond" ${template.titleFont === 'Garamond' ? 'selected' : ''}>Garamond</option>
            </select>
            <input type="number" id="titleFontSize" min="1" value="${template.titleFontSize}"><br/><br/>

            <label>Subtitle Font and Font Size:</label><br/>
            <select id="subtitleFont">
                <option value="Times New Roman" ${template.subtitleFont === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                <option value="Arial" ${template.subtitleFont === 'Arial' ? 'selected' : ''}>Arial</option>
                <option value="Calibri" ${template.subtitleFont === 'Calibri' ? 'selected' : ''}>Calibri</option>
                <option value="Helvetica" ${template.subtitleFont === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Georgia" ${template.subtitleFont === 'Georgia' ? 'selected' : ''}>Georgia</option>
                <option value="Cambria" ${template.subtitleFont === 'Cambria' ? 'selected' : ''}>Cambria</option>
                <option value="Garamond" ${template.subtitleFont === 'Garamond' ? 'selected' : ''}>Garamond</option>
            </select>
            <input type="number" id="subtitleFontSize" min="1" value="${template.subtitleFontSize}"><br/><br/>

            <label>Body Font and Font Size:</label><br/>
            <select id="bodyFont">
                <option value="Times New Roman" ${template.bodyFont === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                <option value="Arial" ${template.bodyFont === 'Arial' ? 'selected' : ''}>Arial</option>
                <option value="Calibri" ${template.bodyFont === 'Calibri' ? 'selected' : ''}>Calibri</option>
                <option value="Helvetica" ${template.bodyFont === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Georgia" ${template.bodyFont === 'Georgia' ? 'selected' : ''}>Georgia</option>
                <option value="Cambria" ${template.bodyFont === 'Cambria' ? 'selected' : ''}>Cambria</option>
                <option value="Garamond" ${template.bodyFont === 'Garamond' ? 'selected' : ''}>Garamond</option>
            </select>
            <input type="number" id="bodyFontSize" min="1" value="${template.bodyFontSize}"><br/><br/>

            <h1>Tags Section (Optional)</h1>
            <div class="form-container">
                <div class="form-group"><label>Test Name </label> <input type="text" id="tempTestName" value="${template.name}"></div>
                <div class="form-group"><label>Date </label> <input type="text" id="tempDate"></div>
                <div class="form-group"><label>Textbook Number </label> <input type="text" id="temptextbookNum"></div>
            </div>

            <h1>Header and Footer Settings</h1>
            <label>Location of Student Score Blank (On the second page of the test)</label>
            <select id="studentScoreSelector">
                <option value="TR" ${template.studentScoreLocation === 'TR' ? 'selected' : ''}>Top Right</option>
                <option value="TL" ${template.studentScoreLocation === 'TL' ? 'selected' : ''}>Top Left</option>
            </select><br/><br/>
            <label>Page Numbers in Header</label><br/>
            <input type="checkbox" id="pageNumH" ${template.pageNumbersInHeader ? 'checked' : ''}><br/>
            <label>Page Numbers in Footer</label><br/>
            <input type="checkbox" id="pageNumF" ${template.pageNumbersInFooter ? 'checked' : ''}><br/><br/>
            <textarea id="headerField" rows="3" placeholder="Enter any desired header text ...">${template.headerText}</textarea>
            <textarea id="footerField" rows="3" placeholder="Enter any desired footer text...">${template.footerText}</textarea>

            <h1>Cover Page Selection</h1><br/>
            <select id="coverPageSelector">
                <option value="" disabled>Please Select a Cover Page</option>
            </select><br/><br/>

            <h1>Test Structure Settings</h1>
            <label>Number of Parts:</label>
            <input type="number" id="partCount" min="1" value="${template.partStructure.length}">
            <button onclick="updateParts()">Update</button>
            <div style="background:#d0d0d0;padding:20px" id="partsContainer"></div>

            <h1>Bonus Question Section Toggle</h1>
            <select id="bonusToggle" onchange="toggleBonusQuestionSelection('${isbn}')">
                <option value="True" ${template.bonusSection ? 'selected' : ''}>Bonus Section</option>
                <option value="False" ${!template.bonusSection ? 'selected' : ''}>No Bonus Section</option>
            </select><br/><br/>
            <button class="add-btn" id="selectBonusQuestionsBtn" style="display:${template.bonusSection ? 'block' : 'none'};" onclick="openBonusQuestionModal('${isbn}')">Select Bonus Questions</button>
            <button class="add-btn" onclick="submitEditTemplate('${isbn}', ${templateIndex})">Submit Template</button>
        </div>
    `;

    modalBody.innerHTML = formContent;

    // Populate the cover page selector
    updatePageSelection(isbn);
    pageSelector = document.getElementById('coverPageSelector');
    pageSelector.value = coverPageType;
    
    // Populate the parts and sections
    updateParts();
    template.partStructure.forEach((part, partIndex) => {
        const sectionCountInput = document.getElementById(`sectionCount-${partIndex + 1}`);
        sectionCountInput.value = part.sections.length;
        updateSections(partIndex + 1);
        part.sections.forEach((section, sectionIndex) => {
            const sectionSelect = document.querySelector(`#sectionsContainer-${partIndex + 1} select:nth-child(${sectionIndex + 1})`);
            // sectionSelect.value = section.questionType;
            // this is not working for some reason
        });
    });



    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This function is used to submit an edited template when the user is finished editing the template from the context menu
 * Precondition: valid isbn, templateIndex
 * Postcondition: template is edited and saved in the master list
*/
function submitEditTemplate(isbn, templateIndex) {
    const templateName = document.getElementById('tempTestName').value.trim();
    const coverPageType = document.getElementById('coverPageSelector').value;

    const titleFont = document.getElementById('titleFont').value.trim();
    const titleFontSize = parseInt(document.getElementById('titleFontSize').value, 10);
    const subtitleFont = document.getElementById('subtitleFont').value.trim();
    const subtitleFontSize = parseInt(document.getElementById('subtitleFontSize').value, 10);
    const bodyFont = document.getElementById('bodyFont').value.trim();
    const bodyFontSize = parseInt(document.getElementById('bodyFontSize').value, 10);

    const pageNumbersInHeader = document.getElementById('pageNumH').checked;
    const pageNumbersInFooter = document.getElementById('pageNumF').checked;

    const headerText = document.getElementById('headerField').value.trim();
    const footerText = document.getElementById('footerField').value.trim();

    const bonusSection = document.getElementById('bonusToggle').value === 'True';

    if (!templateName) {
        alert("Error: Template Name is required.");
        return;
    }
    if (!titleFont || !subtitleFont || !bodyFont) {
        alert("Error: All font fields must be filled.");
        return;
    }
    if (isNaN(titleFontSize) || isNaN(subtitleFontSize) || isNaN(bodyFontSize)) {
        alert("Error: Font sizes must be valid numbers.");
        return;
    }
    if (!coverPageType) {
        alert("Error: You must choose a cover page type.");
        return;
    }
    const partStructure = collectPartStructure();
    if (!partStructure) {
        alert("Error: Template must include a valid part structure.");
        return;
    }

    if(bonusSection){
        if(masterTemplateList[isbn].bonusQuestions.length>0){
            masterTemplateList[isbn][templateIndex].bonusQuestions = masterTemplateList[isbn].bonusQuestions;   
        } else if (masterTemplateList[isbn][templateIndex].bonusQuestions.length>0){
            masterTemplateList[isbn][templateIndex].bonusQuestions = masterTemplateList[isbn][templateIndex].bonusQuestions;
        } else {
            alert("No bonus questions selected!");
            return;
        }
        console.log("Bonus Questions:", masterTemplateList[isbn][templateIndex].bonusQuestions);
    }else{
        alert("no bonus questions!");
        masterTemplateList[isbn][templateIndex].bonusQuestions = [];
        console.log("Bonus Questions:", masterTemplateList[isbn][templateIndex].bonusQuestions);
    }
    if (bonusSection && !masterTemplateList[isbn].bonusQuestions) {
        alert("Bonus questions failed to add to textbook");
        return;
    }else if(bonusSection && (masterTemplateList[isbn][templateIndex].bonusQuestions.length === 0)){
        alert("Bonus questions failed to add to template");
        return;
    }

    const templateData = {
        name: templateName,
        titleFont: titleFont,
        titleFontSize: titleFontSize,
        subtitleFont: subtitleFont,
        subtitleFontSize: subtitleFontSize,
        bodyFont: bodyFont,
        bodyFontSize: bodyFontSize,
        pageNumbersInHeader: pageNumbersInHeader,
        pageNumbersInFooter: pageNumbersInFooter,
        headerText: headerText,
        footerText: footerText,
        coverPageType: coverPageType,
        partStructure: partStructure,
        bonusSection: bonusSection,
        bonusQuestions: masterTemplateList[isbn].bonusQuestions || [],
        feedback: []
    };

    masterTemplateList[isbn][templateIndex] = templateData;
    masterTemplateList[isbn].bonusQuestions = [];

    alert("Template edited successfully!");
    console.log("Edited Template:", templateData);

    updateTemplates(isbn);
    closeModal();
}

/**
 * This function is called to delete a template from the master Templatelist. 
 * Precondition: valid isbn, templateIndex, not published
 * Postcondition: template is deleted from the master list
*/
function deleteTemplate(isbn, templateIndex) {
    if(masterTemplateList[isbn][templateIndex].published === 1){
        alert("This template is published and cannot be deleted.");
        return;
    }
    if (confirm("Are you sure you want to delete this template? This action cannot be undone.")) {
        masterTemplateList[isbn].splice(templateIndex, 1);
        updateTemplates(isbn);
        alert("Template deleted successfully!");
    }
}

/**
 * This function is used to edit a draft test after it has been saved in the master list
 * Precondition: valid isbn, testIndex, not published
 * Postcondition: test is edited and saved in the master list
*/
function editTest(isbn, testIndex) {
    const test = masterTestList[isbn]['drafts'][testIndex];

    // Open the edit modal and populate it with the test data
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'Edit Test';

    const formContent = `
        <div style="background:#e0e0e0;padding:20px;" id="testEditor">
            <label>Test Name:</label><br/>
            <input type="text" id="nameField" value="${test.name}"><br><br>
            <p>Choose a Template!</p><br/>
            <div id="templateSelectorPane">
                <select id="templateSelector">
                    <option value="" disabled>Please Select a Template</option>
                </select> 
                <button id="templateSelection" onclick="updateTestParts('${isbn}')">Select This One!</button>
                <div id="testParts"></div>
            </div>
            <button class="add-btn" id="testDraftButton" onclick="submitEditedTest('${isbn}', '${false}', ${testIndex})">Save as Draft</button>
            <button class="add-btn" id="testPublishButton" onclick="submitEditedTest('${isbn}', '${true}', ${testIndex})">Publish Test</button>
        </div>
    `;

    modalBody.innerHTML = formContent;

    // Populate the template selector
    updateTemplateSelection(isbn);

    // Set the selected template
    const templateSelector = document.getElementById('templateSelector');
    templateSelector.value = test.templateIndex;

    // Populate the test parts
    updateTestParts(isbn);

    // Populate the parts and sections with existing test data
    test.parts.forEach((part, partIndex) => {
        const partContainer = document.getElementById(`part-${partIndex}-container`);
        if (!partContainer) {
            console.error(`Part container not found: part-${partIndex}-container`);
            return;
        }

        part.sections.forEach((section, sectionIndex) => {
            const sectionContainer = document.getElementById(`part-${partIndex}-section-${sectionIndex}-container`);
            if (!sectionContainer) {
                console.error(`Section container not found: part-${partIndex}-section-${sectionIndex}-container`);
                return;
            }

            // Find the selected-questions div within the section container
            const selectedQuestionsContainer = sectionContainer.querySelector('.selected-questions');
            if (!selectedQuestionsContainer) {
                console.error(`Selected questions container not found in section ${partIndex}-${sectionIndex}`);
                return;
            }

            // Create a container for all our question elements
            const selectedQuestionsDiv = document.createElement("div");

            // Create a section-wide point value input
            const sectionPointsDiv = document.createElement("div");
            sectionPointsDiv.innerHTML = `
                <label>Set All Points for This Section: </label>
                <input type="number" id="section-${partIndex}-${sectionIndex}-points" min="1" value="1" style="width: 60px;">
                <button onclick="updateSectionPoints(${partIndex}, ${sectionIndex})">Apply</button>
                <hr>
            `;
            selectedQuestionsDiv.appendChild(sectionPointsDiv);

            // Add each question to the section
            section.questions.forEach((question, questionIndex) => {
                const questionElement = document.createElement("div");
                questionElement.style.padding = "8px";
                questionElement.style.margin = "5px 0";
                questionElement.style.backgroundColor = "#f0f0f0";
                questionElement.style.borderRadius = "4px";
                questionElement.dataset.questionIndex = questionIndex; // Store original index

                questionElement.innerHTML = `
                    <p>${question.text}</p>
                    <label>Points: </label>
                    <input type="number" class="question-points" min="1" value="${question.score}" style="width: 60px;">
                `;

                selectedQuestionsDiv.appendChild(questionElement);
            });
            
            // Append all questions to the selected-questions container
            selectedQuestionsContainer.appendChild(selectedQuestionsDiv);
        });
    });

    // Add bonus part if it exists
    if (test.template && test.template.bonusQuestions && test.template.bonusQuestions.length > 0) {
        const testPartsContainer = document.getElementById("testParts");
        if (!testPartsContainer) {
            console.error("Test parts container not found");
            return;
        }

        const bonusPartContainer = document.createElement("div");
        bonusPartContainer.style.padding = '5px';
        bonusPartContainer.style.marginBottom = '8px';
        bonusPartContainer.style.borderBottom = '1px solid #ccc';
        bonusPartContainer.id = `part-bonus-container`;

        bonusPartContainer.innerHTML = `<h2>Bonus Part</h2>`;

        const bonusSectionContainer = document.createElement('div');
        bonusSectionContainer.style.padding = '5px';
        bonusSectionContainer.style.marginBottom = '8px';
        bonusSectionContainer.style.borderBottom = '1px solid #ccc';
        bonusSectionContainer.style.backgroundColor = '#d3d3d3';
        bonusSectionContainer.id = `bonus-container`;

        bonusSectionContainer.innerHTML = `
            <h3>Bonus Section: Bonus Questions</h3>
        `;

        const selectedQuestionsDiv = document.createElement('div');
        selectedQuestionsDiv.className = 'selected-questions';
        
        test.template.bonusQuestions.forEach((questionId, questionIndex) => {
            const [type, index] = questionId.split('-');
            const question = masterQuestionList[isbn][type][index];
            const questionElement = document.createElement("div");
            questionElement.style.padding = "8px";
            questionElement.style.margin = "5px 0";
            questionElement.style.backgroundColor = "#f0f0f0";
            questionElement.style.borderRadius = "4px";
            questionElement.dataset.questionIndex = questionIndex; // Store original index

            questionElement.innerHTML = `
                <p>${question.text}</p>
                <label>Points: </label>
                <input type="number" class="question-points" min="1" value="${question.score}" style="width: 60px;" disabled>
            `;

            selectedQuestionsDiv.appendChild(questionElement);
        });

        bonusSectionContainer.appendChild(selectedQuestionsDiv);
        bonusPartContainer.appendChild(bonusSectionContainer);
        testPartsContainer.appendChild(bonusPartContainer);
    }

    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This function is called to delete a test from the master test list
 * Precondition: valid isbn, testIndex, not published
 * Postcondition: test is deleted from the master list
*/
function deleteTest(isbn, testIndex) {
    if(masterTestList[isbn]['drafts'][testIndex].published === 1){
        alert("This test is published and cannot be deleted.");
        return;
    }
    if (confirm("Are you sure you want to delete this test? This action cannot be undone.")) {
        const isDraft = masterTestList[isbn]['drafts'][testIndex] !== undefined;
        const targetList = isDraft ? masterTestList[isbn]['drafts'] : masterTestList[isbn]['published'];
        targetList.splice(testIndex, 1);
        updateTestTabs(isbn);
        alert("Test deleted successfully!");
    }
}

/**
 * This function determines whether or not bonus questions are available inside the template
 * Precondition: valid isbn
 * Postcondition: bonus questions are toggled on or off in the template editor
*/
function toggleBonusQuestionSelection(isbn) {
    const bonusToggle = document.getElementById('bonusToggle').value;
    const selectBonusQuestionsBtn = document.getElementById('selectBonusQuestionsBtn');
    if (bonusToggle === 'True') {
        selectBonusQuestionsBtn.style.display = 'block';
    } else {
        selectBonusQuestionsBtn.style.display = 'none';
    }
}

/**
 * The bonus question modal is opened when the user wants to add bonus questions to a template or test
 * Precondition: valid isbn
 * Postcondition: bonus question modal is opened
*/
function openBonusQuestionModal(isbn) {
    const modal = document.getElementById("questionModal");
    const modalTitle = document.getElementById("questionModalTitle");
    const modalBody = document.getElementById("questionModalBody");

    modalBody.innerHTML = ""; // Clear existing content
    
    // Store the relevant data in the modal for later use
    modalBody.dataset.isbn = isbn;
    modalBody.dataset.questionType = 'bonus';

    const questionContainer = document.createElement('div');
    questionContainer.style.padding = '5px';
    questionContainer.style.marginBottom = '8px';
    questionContainer.style.borderBottom = '1px solid #ccc';

    Object.keys(masterQuestionList[isbn]).forEach(type => {
        const questions = masterQuestionList[isbn][type];
        questions.forEach((question, index) => {
            const element = document.createElement("div");
            element.style.padding = '8px';
            element.style.margin = '5px 0';
            element.style.backgroundColor = '#f0f0f0';
            element.style.borderRadius = '4px';
            element.innerHTML = `
                <input type="checkbox" id="q-${type}-${index}" value="${type}-${index}">
                <label for="q-${type}-${index}">${question.text} (${question.score} Points)</label>
            `;   
            questionContainer.appendChild(element);
        });
    });

    const submitButton = document.createElement('button');
    submitButton.className = 'add-btn';
    submitButton.textContent = 'Add Selected Questions';
    submitButton.onclick = function() {
        addSelectedBonusQuestions(isbn);
    };
    questionContainer.appendChild(submitButton);

    modalTitle.innerText = `Select Bonus Questions`;
    modalBody.appendChild(questionContainer);

    modal.style.display = "flex";
    setTimeout(() => {
        modal.style.opacity = "1";
    }, 10);
}

/**
 * This function is called to add selected bonus questions to a template or test, depending on the bonus question modal being open
 * Precondition: valid isbn, bonus questions selected
 * Postcondition: bonus questions are added to the template or test
*/
function addSelectedBonusQuestions(isbn) {
    const modalBody = document.getElementById("questionModalBody");
    const checkboxes = modalBody.querySelectorAll('input[type="checkbox"]:checked');
    const selectedQuestions = Array.from(checkboxes).map(cb => cb.value);

    if (selectedQuestions.length === 0) {
        alert("Please select at least one question.");
        return;
    }

    masterTemplateList[isbn].bonusQuestions = selectedQuestions;
    closeQuestionModal();
    alert(`Added ${selectedQuestions.length} bonus questions.`);
}

/**
 * This renames attachments, not much else to it, it is an editor to facilitate renaming them
 * Precondition: valid attachmentIndex and isbn
 * Postcondition: the attachment editer is opened
*/
function editAttachment(isbn, attachmentIndex) {
    const attachment = masterAttachmentList[isbn][attachmentIndex];

    // Open the edit modal and populate it with the attachment data
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'Edit Attachment';

    const formContent = `
        <label>Attachment Name:</label><br/>
        <input type="text" id="editAttachmentName" value="${attachment.name}"><br><br>
        <button class="add-btn" onclick="submitEditAttachment('${isbn}', ${attachmentIndex})">Submit Edit</button>
    `;

    modalBody.innerHTML = formContent;
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This publishes the changes to the attachment name made in the editAttachment function
 * Precondition: valid isbn, attachmentIndex
 * Postcondition: attachment is renamed
*/
function submitEditAttachment(isbn, attachmentIndex) {
    const newName = document.getElementById('editAttachmentName').value.trim();

    if (!newName) {
        alert("Attachment name is required.");
        return;
    }

    masterAttachmentList[isbn][attachmentIndex].name = newName;
    updateAttachments(isbn);
    closeModal();
    alert("Attachment renamed successfully!");
}

/**
 * This function is called to delete an attachment from the master list
 * Precondition: valid isbn, attachmentIndex
 * Postcondition: attachment is deleted from the master list
 * TODO: Prohibit deletion of published attachments, track published attachments using ID or hash
*/
function deleteAttachment(isbn, attachmentIndex) {
    if (confirm("Are you sure you want to delete this attachment? This action cannot be undone.")) {
        masterAttachmentList[isbn].splice(attachmentIndex, 1);
        updateAttachments(isbn);
        alert("Attachment deleted successfully!");
    }
}

/**
 * This function is called to submit an edited test
 * Precondition: valid isbn, isPublished, testIndex
 * Postcondition: test is edited and saved in the master list
*/
function submitEditedTest(isbn, isPublished, testIndex) {
    const testName = document.getElementById("nameField").value.trim();
    if (!testName) {
        alert("Test Name is required.");
        return;
    }

    const templateIndex = document.getElementById("templateSelector").value;
    if (!templateIndex) {
        alert("Please select a template first");
        return;
    }

    const template = masterTemplateList[isbn][templateIndex];
    
    let usedQuestions = [];

    const testData = {
        name: testName,
        template: template,
        templateName: template.name,
        templateIndex: templateIndex,
        parts: [],
        feedback: []
    };

    // Loop through all parts and sections rendered in the UI
    const testParts = document.getElementById("testParts");
    const partContainers = testParts.querySelectorAll('[id^="part-"][id$="-container"]');
    let noquestions = true;
    partContainers.forEach((partContainer, partIndex) => {
        const partData = {
            partNumber: partIndex + 1,
            sections: []
        };

        // Find all section containers within this part
        const sectionContainers = partContainer.querySelectorAll('[id^="part-' + partIndex + '-section-"]');

        sectionContainers.forEach((sectionContainer, sectionIndex) => {
            const questionType = template.partStructure[partIndex].sections[sectionIndex].questionType;
            const selectedQuestionsDiv = sectionContainer.querySelector('.selected-questions');

            // Skip sections with no questions
            if (!selectedQuestionsDiv || !selectedQuestionsDiv.children.length) {
                return;
            }

            const sectionData = {
                sectionNumber: sectionIndex + 1,
                questionType: questionType,
                questions: []
            };

            // Get all question divs (skip the first child which is the section points setter)
            const questionDivs = selectedQuestionsDiv.querySelectorAll('div[style*="border-radius"]');

            questionDivs.forEach((questionDiv) => {
                const questionIndex = questionDiv.dataset.questionIndex;
                const pointsInput = questionDiv.querySelector('.question-points');
                const points = pointsInput ? parseInt(pointsInput.value) : 1; //if there are no points, make it 1 point

                // Get the question from master list and clone it
                const question = JSON.parse(JSON.stringify(masterQuestionList[isbn][questionType.toLowerCase()][questionIndex]));

                // Update points for this clone if they were changed
                question.score = points;
                usedQuestions.push(masterQuestionList[isbn][questionType.toLowerCase()][questionIndex]);
                // Add to the questions for this section
                sectionData.questions.push(question);
                noquestions=false;
                // Set the published key to 1 if the test is published
                if (isPublished === 'true') {
                    masterQuestionList[isbn][questionType.toLowerCase()][questionIndex].published = 1;
                }
            });
            if(noquestions){
                alert("Please select questions for each section");
                return;
            }
            partData.sections.push(sectionData);
        });

        testData.parts.push(partData);
    });

    if (template.bonusSection) {
        const bonusPart = {
            partNumber: testData.parts.length + 1,
            sections: [{
                sectionNumber: 1,
                questionType: 'bonus',
                questions: template.bonusQuestions.map(q => {
                    const [type, index] = q.split('-');
                    const question = masterQuestionList[isbn][type][index];
                    if (isPublished === 'true') {
                        question.published = 1;
                    }
                    return question;
                })
            }]
        };
        testData.parts.push(bonusPart);
    }

    // Save the test data
    if (!masterTestList[isbn]) {
        masterTestList[isbn] = { drafts: [], published: [] };
    }

    const draftsList = masterTestList[isbn].drafts;
    const publishedList = masterTestList[isbn].published;

    if (isPublished === 'true') {
        // Remove from drafts and add to published
        draftsList.splice(testIndex, 1);
        testData.published = 1;
        publishedList.push(testData);
    } else {
        // Update the draft test
        draftsList[testIndex] = testData;
    }

    // Set the published key for the template and cover page if the test is published
    if (isPublished === 'true') {
        masterTemplateList[isbn][templateIndex].published = 1;
        const coverPageIndex = template.coverPageType;
        if (masterCoverPageList[isbn][coverPageIndex]) {
            masterCoverPageList[isbn][coverPageIndex].published = 1;
        }
    }

    usedQuestions.forEach(question => {
        question.tests.push(testData.name);
        console.log("Updated question:", question);
        console.log("Question published value:", question.published);
    });

    alert(`Test "${testName}" saved successfully as ${isPublished === 'true' ? "Published" : "Draft"}!`);
    updateTestTabs(isbn);
    closeModal();
}

/**
 * This function opens up the modal to produce a feedback form
 * It allows the user to leave a rating out of five stars, the average score, average time taken, and comments
 * Precondition: valid isbn, questionType, questionIndex
 * Postcondition: feedback form is opened 
 * TODO: add average time taken field
*/
function addFeedback() {
    const contextMenu = document.getElementById('contextMenu');
    const itemType = contextMenu.dataset.itemType;
    const itemIndex = contextMenu.dataset.itemIndex;
    const isbn = contextMenu.dataset.isbn;
    const questionType = contextMenu.dataset.questionType;

    if (itemType === 'question') {
        const question = masterQuestionList[isbn][questionType][itemIndex];

        // Open the feedback modal and populate it with the feedback form
        const modal = document.getElementById('editModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');

        modalTitle.innerText = 'Add Feedback';

        const formContent = `
            <label>Rating (1-5):</label><br/>
            <input type="number" id="feedbackRating" min="1" max="5"><br><br>
            <label>Class Average Score:</label><br/>
            <input type="number" id="feedbackAverageScore" min="0"><br><br>
            <label>Comments:</label><br/>
            <textarea id="feedbackComments" rows="4"></textarea><br><br>
            <button class="add-btn" onclick="submitFeedback('${isbn}', '${questionType}', ${itemIndex})">Submit Feedback</button>
        `;

        modalBody.innerHTML = formContent;
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.style.opacity = '1';
        }, 10);
    } else if (itemType === 'test') {
        const test = masterTestList[isbn]['drafts'][itemIndex] || masterTestList[isbn]['published'][itemIndex];

        // Open the feedback modal and populate it with the feedback form
        const modal = document.getElementById('editModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');

        modalTitle.innerText = 'Add Feedback';

        const formContent = `
            <label>Rating (1-5):</label><br/>
            <input type="number" id="feedbackRating" min="1" max="5"><br><br>
            <label>Class Average Score:</label><br/>
            <input type="number" id="feedbackAverageScore" min="0"><br><br>
            <label>Comments:</label><br/>
            <textarea id="feedbackComments" rows="4"></textarea><br><br>
            <button class="add-btn" onclick="submitTestFeedback('${isbn}', ${itemIndex})">Submit Feedback</button>
        `;

        modalBody.innerHTML = formContent;
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.style.opacity = '1';
        }, 10);
    } else {
        alert("Feedback can only be added to questions and tests.");
    }
}

/**
 * This function is called to submit feedback for a question
 * Precondition: valid isbn, questionType, questionIndex
 * Postcondition: feedback is submitted and saved in the master list
*/
function submitFeedback(isbn, questionType, questionIndex) {
    const rating = parseInt(document.getElementById('feedbackRating').value);
    const averageScore = parseFloat(document.getElementById('feedbackAverageScore').value);
    const comments = document.getElementById('feedbackComments').value.trim();

    if (isNaN(rating) || rating < 1 || rating > 5) {
        alert("Please enter a valid rating between 1 and 5.");
        return;
    }
    if (isNaN(averageScore) || averageScore < 0) {
        alert("Please enter a valid, non-negative class average score.");
        return;
    }
    if (!comments) {
        alert("Comments are required.");
        return;
    }

    const feedback = {
        username: isbn, // Using isbn as the username for now
        rating: rating,
        averageScore: averageScore,
        comments: comments,
        date: new Date().toLocaleString(),
        responses: []
    };

    const question = masterQuestionList[isbn][questionType][questionIndex];
    if (!question.feedback) {
        question.feedback = [];
    }
    question.feedback.push(feedback);

    alert("Feedback submitted successfully!");
    closeModal();
    viewQuestionFeedback(isbn, questionType, questionIndex);
}

/**
 * This function is called to submit feedback for a test
 * Precondition: valid isbn, testIndex
 * Postcondition: feedback is submitted and saved in the master list
*/
function submitTestFeedback(isbn, testIndex) {
    const rating = parseInt(document.getElementById('feedbackRating').value);
    const averageScore = parseFloat(document.getElementById('feedbackAverageScore').value);
    const comments = document.getElementById('feedbackComments').value.trim();

    if (isNaN(rating) || rating < 1 || rating > 5) {
        alert("Please enter a valid rating between 1 and 5.");
        return;
    }
    if (isNaN(averageScore) || averageScore < 0) {
        alert("Please enter a valid, non-negative class average score.");
        return;
    }
    if (!comments) {
        alert("Comments are required.");
        return;
    }

    const feedback = {
        username: isbn, // Using isbn as the username for now
        rating: rating,
        averageScore: averageScore,
        comments: comments,
        date: new Date().toLocaleString(),
        responses: []
    };

    const test = masterTestList[isbn]['drafts'][testIndex] || masterTestList[isbn]['published'][testIndex];
    if (!test.feedback) {
        test.feedback = [];
    }
    test.feedback.push(feedback);

    alert("Feedback submitted successfully!");
    closeModal();
    viewTestFeedback(isbn, testIndex);
}

/**
 * This function is called to view feedback for a question or test
 * It opens up an amazon review-like page
 * Precondition: valid isbn, questionType (for questions), questionIndex stored in context menu
 * Postcondition: feedback is displayed in the modal
*/
function viewFeedback() {
    const contextMenu = document.getElementById('contextMenu');
    const itemType = contextMenu.dataset.itemType;
    const itemIndex = contextMenu.dataset.itemIndex;
    const isbn = contextMenu.dataset.isbn;
    const questionType = contextMenu.dataset.questionType;

    if (itemType === 'question') {
        viewQuestionFeedback(isbn, questionType, itemIndex);
    } else if (itemType === 'test') {
        viewTestFeedback(isbn, itemIndex);
    } else {
        alert("Feedback can only be viewed for questions and tests.");
    }
}

/**
 * This function is called to view the feedback to questions, it is called by viewFeedback
 * Precondition: valid isbn, questionType, questionIndex
 * Postcondition: feedback is displayed in the modal
*/
function viewQuestionFeedback(isbn, questionType, questionIndex) {
    const question = masterQuestionList[isbn][questionType][questionIndex];

    // Open the feedback modal and populate it with the feedback reviews
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'View Feedback';

    let feedbackContent = '<h3>Feedback Reviews:</h3>';
    if (!question.feedback || question.feedback.length === 0) {
        feedbackContent += '<p>No feedback available for this question.</p>';
    } else {
        question.feedback.forEach((feedback, feedbackIndex) => {
            feedbackContent += `
                <div style="border-bottom: 1px solid #ccc; padding: 10px;">
                    <p><strong>${feedback.username}</strong> (${feedback.date})</p>
                    <p>Rating: ${feedback.rating}/5</p>
                    <p>Class Average Score: ${feedback.averageScore}/${question.score}</p>
                    <p>Comments: ${feedback.comments}</p>
                    <div id="responses-${feedbackIndex}">
                        ${feedback.responses.map(response => `
                            <div style="margin-left: 20px; border-top: 1px solid #ccc; padding-top: 10px;">
                                <p><strong>${response.username}</strong> (${response.date})</p>
                                <p>${response.text}</p>
                            </div>
                        `).join('')}
                    </div>
                    <textarea id="responseText-${feedbackIndex}" rows="2" placeholder="Add a response..."></textarea><br>
                    <button class="add-btn" onclick="submitResponse('${isbn}', '${questionType}', ${questionIndex}, ${feedbackIndex})">Submit Response</button>
                </div>
            `;
        });
    }

    modalBody.innerHTML = feedbackContent;
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This function is called to view the feedback to tests, it is called by viewFeedback
 * Precondition: valid isbn, testIndex
 * Postcondition: feedback is displayed in the modal
*/
function viewTestFeedback(isbn, testIndex) {
    const test = masterTestList[isbn]['drafts'][testIndex] || masterTestList[isbn]['published'][testIndex];

    // Open the feedback modal and populate it with the feedback reviews
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');

    modalTitle.innerText = 'View Feedback';

    let feedbackContent = '<h3>Feedback Reviews:</h3>';
    if (!test.feedback || test.feedback.length === 0) {
        feedbackContent += '<p>No feedback available for this test.</p>';
    } else {
        test.feedback.forEach((feedback, feedbackIndex) => {
            feedbackContent += `
                <div style="border-bottom: 1px solid #ccc; padding: 10px;">
                    <p><strong>${feedback.username}</strong> (${feedback.date})</p>
                    <p>Rating: ${feedback.rating}/5</p>
                    <p>Class Average Score: ${feedback.averageScore}</p>
                    <p>Comments: ${feedback.comments}</p>
                    <div id="responses-${feedbackIndex}">
                        ${feedback.responses.map(response => `
                            <div style="margin-left: 20px; border-top: 1px solid #ccc; padding-top: 10px;">
                                <p><strong>${response.username}</strong> (${response.date})</p>
                                <p>${response.text}</p>
                            </div>
                        `).join('')}
                    </div>
                    <textarea id="responseText-${feedbackIndex}" rows="2" placeholder="Add a response..."></textarea><br>
                    <button class="add-btn" onclick="submitTestResponse('${isbn}', ${testIndex}, ${feedbackIndex})">Submit Response</button>
                </div>
            `;
        });
    }

    modalBody.innerHTML = feedbackContent;
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

/**
 * This function is called to submit response inside of the feedback modal
 * Precondition: valid isbn, questionType, questionIndex, feedbackIndex
 * Postcondition: response is submitted and saved in the master list, displayed on the review page
*/
function submitResponse(isbn, questionType, questionIndex, feedbackIndex) {
    const responseText = document.getElementById(`responseText-${feedbackIndex}`).value.trim();

    if (!responseText) {
        alert("Response text is required.");
        return;
    }

    const response = {
        username: isbn, // Using isbn as the username for now
        text: responseText,
        date: new Date().toLocaleString()
    };

    const question = masterQuestionList[isbn][questionType][questionIndex];
    question.feedback[feedbackIndex].responses.push(response);

    alert("Response submitted successfully!");
    viewQuestionFeedback(isbn, questionType, questionIndex);
}

/**
 * This function is called to submit response inside of the feedback modal for tests
 * Precondition: valid isbn, testIndex, feedbackIndex
 * Postcondition: response is submitted and saved in the master list, displayed on the review page
*/
function submitTestResponse(isbn, testIndex, feedbackIndex) {
    const responseText = document.getElementById(`responseText-${feedbackIndex}`).value.trim();

    if (!responseText) {
        alert("Response text is required.");
        return;
    }

    const response = {
        username: isbn, // Using isbn as the username for now
        text: responseText,
        date: new Date().toLocaleString()
    };

    const test = masterTestList[isbn]['drafts'][testIndex] || masterTestList[isbn]['published'][testIndex];
    test.feedback[feedbackIndex].responses.push(response);

    alert("Response submitted successfully!");
    viewTestFeedback(isbn, testIndex);
}

/**
 * This function is called to update the options inside of the question editor when first creating a question
 * Precondition: valid question type
 * Postcondition: options are updated in the question editor
*/
function updateOptions(type) {
    const optionsContainer = document.getElementById('optionsContainer');
    optionsContainer.innerHTML = '';

    if (type === 'ma') {
        const numOptions = parseInt(document.getElementById('numOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            optionsContainer.innerHTML += `
                <label>Option ${i}:</label><br/>
                <input type="text" id="option${i}" placeholder="Option ${i}"><br><br>
            `;
        }
    } else if (type === 'ms') {
        const numOptions = parseInt(document.getElementById('numOptions').value);
        for (let i = 1; i <= numOptions; i++) {
            optionsContainer.innerHTML += `
                <label>Option ${i}:</label><br/>
                <input type="text" id="option${i}" placeholder="Option ${i}"><br>
                <label>Correct Answer:</label>
                <input type="checkbox" id="correct${i}"><br><br>
            `;
        }
    } else if (type === 'fb') {
        const numBlanks = parseInt(document.getElementById('numBlanks').value);
        for (let i = 1; i <= numBlanks; i++) {
            optionsContainer.innerHTML += `
                <label>Answer for Blank ${i}:</label><br/>
                <input type="text" id="blank${i}" placeholder="Answer for Blank ${i}"><br><br>
            `;
        }
    }
}


</script>
</body>
</html>
